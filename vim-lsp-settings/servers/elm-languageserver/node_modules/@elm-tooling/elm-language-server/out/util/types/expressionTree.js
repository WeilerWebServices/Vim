"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findDefinition = exports.mapSyntaxNodeToExpression = void 0;
const treeUtils_1 = require("../treeUtils");
const utils_1 = require("../utils");
function mapSyntaxNodeToExpression(node) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5;
    if (!node)
        return;
    switch (node.type) {
        case "lower_case_identifier":
            return node;
        case "value_declaration":
            {
                const body = mapSyntaxNodeToExpression(node.namedChildren[node.namedChildren.length - 1]);
                const typeAnnotation = mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.getTypeAnnotation(node));
                if (body) {
                    const params = (_b = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.namedChildren.slice(1).map((a) => a.text)) !== null && _b !== void 0 ? _b : [];
                    return Object.assign(node, {
                        nodeType: "ValueDeclaration",
                        params,
                        body,
                        typeAnnotation,
                        pattern: mapSyntaxNodeToExpression(node.childForFieldName("pattern")),
                    });
                }
            }
            break;
        case "value_expr":
            return Object.assign(node, {
                nodeType: "ValueExpr",
                name: node.text,
            });
        case "bin_op_expr": {
            return Object.assign(node, {
                nodeType: "BinOpExpr",
                parts: node.children
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        }
        case "operator_identifier": {
            return Object.assign(node, {
                nodeType: "Operator",
            });
        }
        case "number_constant_expr":
            return Object.assign(node, {
                nodeType: "NumberConstant",
                isFloat: node.text.includes("."),
            });
        case "string_constant_expr":
            return Object.assign(node, {
                nodeType: "StringConstant",
            });
        case "parenthesized_expr":
            return mapSyntaxNodeToExpression(node.children[1]);
        case "function_call_expr":
            {
                const target = mapSyntaxNodeToExpression(node.firstNamedChild);
                if (target) {
                    return Object.assign(node, {
                        nodeType: "FunctionCallExpr",
                        target,
                        args: node.children
                            .slice(1)
                            .map(mapSyntaxNodeToExpression)
                            .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
                    });
                }
            }
            break;
        case "type_annotation":
            return Object.assign(node, {
                nodeType: "TypeAnnotation",
                name: (_d = (_c = node.firstNamedChild) === null || _c === void 0 ? void 0 : _c.text) !== null && _d !== void 0 ? _d : "",
                typeExpression: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("type_expression", node)),
            });
        case "type_expression":
            return Object.assign(node, {
                nodeType: "TypeExpression",
                segments: node.children
                    .filter((n) => n.type !== "arrow" &&
                    n.type !== "left_parenthesis" &&
                    n.type !== "right_parenthesis")
                    .map(mapSyntaxNodeToExpression),
            });
        case "type_variable":
            return Object.assign(node, { nodeType: "TypeVariable" });
        case "type_ref":
            return Object.assign(node, { nodeType: "TypeRef" });
        case "type_declaration":
            return Object.assign(node, {
                nodeType: "TypeDeclaration",
                name: (_f = (_e = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node)) === null || _e === void 0 ? void 0 : _e.text) !== null && _f !== void 0 ? _f : "",
                moduleName: (_h = (_g = treeUtils_1.TreeUtils.getModuleNameNode(node.tree)) === null || _g === void 0 ? void 0 : _g.text) !== null && _h !== void 0 ? _h : "",
                unionVariants: treeUtils_1.TreeUtils.findAllNamedChildrenOfType("union_variant", node),
                typeNames: (_j = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_type_name", node)) !== null && _j !== void 0 ? _j : [],
            });
        case "infix_declaration":
            return Object.assign(node, {
                nodeType: "InfixDeclaration",
                precedence: parseInt((_l = (_k = treeUtils_1.TreeUtils.findFirstNamedChildOfType("number_literal", node)) === null || _k === void 0 ? void 0 : _k.text) !== null && _l !== void 0 ? _l : ""),
                associativity: (_o = (_m = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", node)) === null || _m === void 0 ? void 0 : _m.text.toUpperCase()) !== null && _o !== void 0 ? _o : "NON",
            });
        case "function_declaration_left":
            return Object.assign(node, {
                nodeType: "FunctionDeclarationLeft",
                params: (_p = node.namedChildren
                    .filter((n) => n.type.includes("pattern"))) === null || _p === void 0 ? void 0 : _p.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "pattern": {
            const asNode = treeUtils_1.TreeUtils.findFirstNamedChildOfType("as", node);
            return Object.assign(node, {
                nodeType: "Pattern",
                patternAs: mapSyntaxNodeToExpression(asNode === null || asNode === void 0 ? void 0 : asNode.nextNamedSibling),
            });
        }
        case "lower_pattern":
            return Object.assign(node, {
                nodeType: "LowerPattern",
            });
        case "lower_type_name":
            return Object.assign(node, {
                nodeType: "LowerTypeName",
            });
        case "union_variant":
            return Object.assign(node, {
                nodeType: "UnionVariant",
                name: (_r = (_q = node.firstNamedChild) === null || _q === void 0 ? void 0 : _q.text) !== null && _r !== void 0 ? _r : "",
                params: node.namedChildren
                    .slice(1)
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "if_else_expr":
            return Object.assign(node, {
                nodeType: "IfElseExpr",
                exprList: node.namedChildren
                    .map((n) => mapSyntaxNodeToExpression(n))
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "let_in_expr":
            return Object.assign(node, {
                nodeType: "LetInExpr",
                valueDeclarations: (_t = (_s = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("value_declaration", node)) === null || _s === void 0 ? void 0 : _s.map(mapSyntaxNodeToExpression)) !== null && _t !== void 0 ? _t : [],
                body: mapSyntaxNodeToExpression(node.lastNamedChild),
            });
        case "case_of_expr":
            return Object.assign(node, {
                nodeType: "CaseOfExpr",
                expr: mapSyntaxNodeToExpression(node.namedChildren[1]),
                branches: node.namedChildren
                    .slice(3)
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "case_of_branch":
            return Object.assign(node, {
                nodeType: "CaseOfBranch",
                pattern: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("pattern", node)),
                expr: mapSyntaxNodeToExpression(node.lastNamedChild),
            });
        case "anonymous_function_expr":
            return Object.assign(node, {
                nodeType: "AnonymousFunctionExpr",
                params: (_u = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("pattern", node)) === null || _u === void 0 ? void 0 : _u.map(mapSyntaxNodeToExpression).filter((n) => (n === null || n === void 0 ? void 0 : n.nodeType) === "Pattern"),
                expr: mapSyntaxNodeToExpression(node.lastNamedChild),
            });
        case "unit_expr":
            return Object.assign(node, {
                nodeType: "UnitExpr",
            });
        case "tuple_expr":
            return Object.assign(node, {
                nodeType: "TupleExpr",
                exprList: node.namedChildren
                    .filter((n) => n.type !== "left_parenthesis" &&
                    n.type !== "comma" &&
                    n.type !== "right_parenthesis")
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "anything_pattern":
            return Object.assign(node, {
                nodeType: "AnythingPattern",
            });
        case "tuple_pattern":
            return Object.assign(node, {
                nodeType: "TuplePattern",
                patterns: (_v = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("pattern", node)) === null || _v === void 0 ? void 0 : _v.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "tuple_type":
            return Object.assign(node, {
                nodeType: "TupleType",
                typeExpressions: (_w = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("type_expression", node)) === null || _w === void 0 ? void 0 : _w.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
                unitExpr: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("unit_expr", node)),
            });
        case "list_expr":
            return Object.assign(node, {
                nodeType: "ListExpr",
                exprList: node.namedChildren
                    .filter((n) => n.type.endsWith("expr"))
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "list_pattern":
            return Object.assign(node, {
                nodeType: "ListPattern",
                parts: node.namedChildren
                    .filter((n) => n.type.includes("pattern"))
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "union_pattern":
            return Object.assign(node, {
                nodeType: "UnionPattern",
                constructor: node.firstNamedChild,
                namedParams: node
                    .descendantsOfType("lower_pattern")
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
                argPatterns: node.namedChildren
                    .slice(1)
                    .filter((node) => node.type.includes("pattern") || node.type.includes("constant"))
                    .map((node) => { var _a; return (_a = mapSyntaxNodeToExpression(node)) !== null && _a !== void 0 ? _a : node; }),
            });
        case "cons_pattern":
            return Object.assign(node, {
                nodeType: "ConsPattern",
                parts: node.namedChildren
                    .filter((n) => n.type.includes("pattern"))
                    .map(mapSyntaxNodeToExpression)
                    .filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "record_type":
            return Object.assign(node, {
                nodeType: "RecordType",
                baseType: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("record_base_identifier", node)),
                fieldTypes: (_x = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("field_type", node)) === null || _x === void 0 ? void 0 : _x.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "field_type":
            return Object.assign(node, {
                nodeType: "FieldType",
                name: (_z = (_y = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", node)) === null || _y === void 0 ? void 0 : _y.text) !== null && _z !== void 0 ? _z : "",
                typeExpression: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("type_expression", node)),
            });
        case "type_alias_declaration":
            return Object.assign(node, {
                nodeType: "TypeAliasDeclaration",
                name: treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node),
                typeVariables: (_1 = (_0 = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_type_name", node)) === null || _0 === void 0 ? void 0 : _0.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression))) !== null && _1 !== void 0 ? _1 : [],
                typeExpression: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("type_expression", node)),
            });
        case "field":
            return Object.assign(node, {
                nodeType: "Field",
                name: node.firstNamedChild,
                expression: mapSyntaxNodeToExpression(node.lastNamedChild),
            });
        case "field_access_expr":
            return Object.assign(node, {
                nodeType: "FieldAccessExpr",
                target: mapSyntaxNodeToExpression(node.firstNamedChild),
            });
        case "field_accessor_function_expr":
            return Object.assign(node, {
                nodeType: "FieldAccessorFunctionExpr",
            });
        case "record_pattern":
            return Object.assign(node, {
                nodeType: "RecordPattern",
                patternList: (_2 = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("lower_pattern", node)) === null || _2 === void 0 ? void 0 : _2.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "record_expr":
            return Object.assign(node, {
                nodeType: "RecordExpr",
                baseRecord: treeUtils_1.TreeUtils.findFirstNamedChildOfType("record_base_identifier", node),
                fields: (_3 = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("field", node)) === null || _3 === void 0 ? void 0 : _3.map(mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(mapSyntaxNodeToExpression)),
            });
        case "port_annotation":
            return Object.assign(node, {
                nodeType: "PortAnnotation",
                name: (_5 = (_4 = node.children[1]) === null || _4 === void 0 ? void 0 : _4.text) !== null && _5 !== void 0 ? _5 : "",
                typeExpression: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("type_expression", node)),
            });
        case "char_constant_expr":
            return Object.assign(node, {
                nodeType: "CharConstantExpr",
            });
        case "glsl_code_expr":
            return Object.assign(node, {
                nodeType: "GlslCodeExpr",
                content: treeUtils_1.TreeUtils.findFirstNamedChildOfType("glsl_content", node),
            });
        case "operator_as_function_expr":
            return Object.assign(node, {
                nodeType: "OperatorAsFunctionExpr",
                operator: mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("operator_identifier", node)),
            });
        case "negate_expr":
            return Object.assign(node, {
                nodeType: "NegateExpr",
                expression: mapSyntaxNodeToExpression(node.lastNamedChild),
            });
        case "nullary_constructor_argument_pattern":
            return Object.assign(node, {
                nodeType: "NullaryConstructorArgumentPattern",
            });
        default:
            return mapSyntaxNodeToExpression(node.firstNamedChild);
    }
}
exports.mapSyntaxNodeToExpression = mapSyntaxNodeToExpression;
function findDefinition(e, uri, elmWorkspace) {
    if (!e) {
        return;
    }
    const definition = treeUtils_1.TreeUtils.findDefinitionNodeByReferencingNodeShallow(e, uri, e.tree, elmWorkspace);
    const mappedNode = mapSyntaxNodeToExpression(definition === null || definition === void 0 ? void 0 : definition.node);
    if (mappedNode && definition) {
        return {
            expr: mappedNode,
            uri: definition.uri,
        };
    }
}
exports.findDefinition = findDefinition;
//# sourceMappingURL=expressionTree.js.map