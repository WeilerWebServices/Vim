import { InferenceResult } from "./typeInference";
import { Expression, ETypeDeclaration, ETypeAnnotation, EUnionVariant, ETypeAliasDeclaration, EPortAnnotation } from "./expressionTree";
import { IElmWorkspace } from "src/elmWorkspace";
export declare class TypeExpression {
    private root;
    private uri;
    private workspace;
    private rigidVars;
    private activeAliases;
    private varsByExpression;
    private expressionTypes;
    private diagnostics;
    constructor(root: Expression, uri: string, workspace: IElmWorkspace, rigidVars: boolean, activeAliases?: Set<ETypeAliasDeclaration>);
    static typeDeclarationInference(e: ETypeDeclaration, uri: string, workspace: IElmWorkspace): InferenceResult;
    static typeAliasDeclarationInference(e: ETypeAliasDeclaration, uri: string, workspace: IElmWorkspace, activeAliases?: Set<ETypeAliasDeclaration>): InferenceResult;
    static typeAnnotationInference(e: ETypeAnnotation, uri: string, workspace: IElmWorkspace, rigid?: boolean): InferenceResult | undefined;
    static unionVariantInference(e: EUnionVariant, uri: string, workspace: IElmWorkspace): InferenceResult;
    static portAnnotationInference(e: EPortAnnotation, uri: string, workspace: IElmWorkspace): InferenceResult;
    private inferTypeDeclaration;
    private inferTypeExpression;
    private inferUnionConstructor;
    private inferPortAnnotation;
    private inferTypeAliasDeclaration;
    private typeExpressionType;
    private toResult;
    private typeSignatureSegmentType;
    private typeVariableType;
    private recordTypeDeclarationType;
    private typeRefType;
    private typeDeclarationType;
    private getTypeVar;
}
