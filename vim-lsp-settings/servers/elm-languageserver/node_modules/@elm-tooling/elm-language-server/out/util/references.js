"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.References = void 0;
const treeUtils_1 = require("./treeUtils");
const utils_1 = require("./utils");
class References {
    static find(definitionNode, elmWorkspace) {
        var _a, _b, _c;
        const references = [];
        const forest = elmWorkspace.getForest();
        const imports = elmWorkspace.getImports();
        if (definitionNode) {
            const refSourceTree = forest.getByUri(definitionNode.uri);
            if (refSourceTree) {
                const moduleNameNode = treeUtils_1.TreeUtils.getModuleNameNode(refSourceTree.tree);
                switch (definitionNode.nodeType) {
                    case "Function":
                        {
                            const annotationNameNode = this.getFunctionAnnotationNameNodeFromDefinition(definitionNode.node);
                            if (annotationNameNode && refSourceTree.writeable) {
                                references.push({
                                    node: annotationNameNode,
                                    uri: definitionNode.uri,
                                });
                            }
                            const functionNameNode = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(definitionNode.node);
                            if (functionNameNode) {
                                if (refSourceTree.writeable) {
                                    references.push({
                                        node: functionNameNode,
                                        uri: definitionNode.uri,
                                    });
                                }
                                const localFunctions = ((_a = definitionNode.node.parent) === null || _a === void 0 ? void 0 : _a.parent) &&
                                    ((_b = definitionNode.node.parent) === null || _b === void 0 ? void 0 : _b.parent.type) === "let_in_expr" && ((_c = definitionNode.node.parent) === null || _c === void 0 ? void 0 : _c.parent.lastNamedChild)
                                    ? this.findFunctionCalls(definitionNode.node.parent.parent.lastNamedChild, functionNameNode.text)
                                    : this.findFunctionCalls(refSourceTree.tree.rootNode, functionNameNode.text);
                                if (localFunctions && refSourceTree.writeable) {
                                    references.push(...localFunctions.map((node) => {
                                        return { node, uri: definitionNode.uri };
                                    }));
                                }
                                if (treeUtils_1.TreeUtils.isExposedFunction(refSourceTree.tree, functionNameNode.text)) {
                                    const moduleDeclarationNode = treeUtils_1.TreeUtils.findModuleDeclaration(refSourceTree.tree);
                                    if (moduleDeclarationNode) {
                                        const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(moduleDeclarationNode, functionNameNode.text);
                                        if (exposedNode && refSourceTree.writeable) {
                                            references.push({
                                                node: exposedNode,
                                                uri: definitionNode.uri,
                                            });
                                        }
                                    }
                                    if (moduleNameNode) {
                                        for (const uri in imports.imports) {
                                            if (imports.imports.hasOwnProperty(uri)) {
                                                const element = imports.imports[uri];
                                                const needsToBeChecked = element.filter((a) => uri !== definitionNode.uri &&
                                                    a.fromModuleName === moduleNameNode.text &&
                                                    a.type === "Function" &&
                                                    (a.alias.endsWith(`.${functionNameNode.text}`) ||
                                                        a.alias === functionNameNode.text));
                                                if (needsToBeChecked.length > 0) {
                                                    const treeToCheck = forest.getByUri(uri);
                                                    if (treeToCheck && treeToCheck.writeable) {
                                                        const importClauseNode = treeUtils_1.TreeUtils.findImportClauseByName(treeToCheck.tree, moduleNameNode.text);
                                                        if (importClauseNode) {
                                                            const exposedNode = treeUtils_1.TreeUtils.findExposedFunctionNode(importClauseNode, functionNameNode.text);
                                                            if (exposedNode) {
                                                                references.push({
                                                                    node: exposedNode,
                                                                    uri,
                                                                });
                                                            }
                                                        }
                                                        needsToBeChecked.forEach((a) => {
                                                            const functions = this.findFunctionCalls(treeToCheck.tree.rootNode, a.alias);
                                                            if (functions) {
                                                                references.push(...functions.map((node) => {
                                                                    return { node, uri };
                                                                }));
                                                            }
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Type":
                    case "TypeAlias":
                        {
                            const typeOrTypeAliasNameNode = treeUtils_1.TreeUtils.getTypeOrTypeAliasNameNodeFromDefinition(definitionNode.node);
                            if (typeOrTypeAliasNameNode) {
                                if (refSourceTree.writeable) {
                                    references.push({
                                        node: typeOrTypeAliasNameNode,
                                        uri: definitionNode.uri,
                                    });
                                }
                                const localFunctions = treeUtils_1.TreeUtils.findTypeOrTypeAliasCalls(refSourceTree.tree, typeOrTypeAliasNameNode.text);
                                if (localFunctions && refSourceTree.writeable) {
                                    references.push(...localFunctions.map((node) => {
                                        return { node, uri: definitionNode.uri };
                                    }));
                                }
                                if (treeUtils_1.TreeUtils.isExposedTypeOrTypeAlias(refSourceTree.tree, typeOrTypeAliasNameNode.text)) {
                                    const moduleDeclarationNode = treeUtils_1.TreeUtils.findModuleDeclaration(refSourceTree.tree);
                                    if (moduleDeclarationNode) {
                                        const exposedNode = treeUtils_1.TreeUtils.findExposedTypeOrTypeAliasNode(moduleDeclarationNode, typeOrTypeAliasNameNode.text);
                                        if (exposedNode && refSourceTree.writeable) {
                                            references.push({
                                                node: exposedNode,
                                                uri: definitionNode.uri,
                                            });
                                        }
                                    }
                                    if (moduleNameNode) {
                                        for (const uri in imports.imports) {
                                            if (imports.imports.hasOwnProperty(uri)) {
                                                const element = imports.imports[uri];
                                                const needsToBeChecked = element.filter((a) => uri !== definitionNode.uri &&
                                                    a.fromModuleName === moduleNameNode.text &&
                                                    (a.type === "Type" || a.type === "TypeAlias") &&
                                                    (a.alias.endsWith(`.${typeOrTypeAliasNameNode.text}`) ||
                                                        a.alias === typeOrTypeAliasNameNode.text));
                                                if (needsToBeChecked.length > 0) {
                                                    const treeToCheck = forest.getByUri(uri);
                                                    if (treeToCheck && treeToCheck.writeable) {
                                                        const importClauseNode = treeUtils_1.TreeUtils.findImportClauseByName(treeToCheck.tree, moduleNameNode.text);
                                                        if (importClauseNode) {
                                                            const exposedNode = treeUtils_1.TreeUtils.findExposedTypeOrTypeAliasNode(importClauseNode, typeOrTypeAliasNameNode.text);
                                                            if (exposedNode) {
                                                                references.push({
                                                                    node: exposedNode,
                                                                    uri,
                                                                });
                                                            }
                                                        }
                                                        needsToBeChecked.forEach((a) => {
                                                            const typeOrTypeAliasCalls = treeUtils_1.TreeUtils.findTypeOrTypeAliasCalls(treeToCheck.tree, a.alias);
                                                            if (typeOrTypeAliasCalls) {
                                                                references.push(...typeOrTypeAliasCalls.map((node) => {
                                                                    return { node, uri };
                                                                }));
                                                            }
                                                        });
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Module":
                        if (moduleNameNode) {
                            if (refSourceTree.writeable) {
                                references.push({
                                    node: moduleNameNode,
                                    uri: definitionNode.uri,
                                });
                            }
                            for (const uri in imports.imports) {
                                if (imports.imports.hasOwnProperty(uri)) {
                                    const element = imports.imports[uri];
                                    const needsToBeChecked = element.filter((a) => uri !== definitionNode.uri &&
                                        a.fromModuleName === moduleNameNode.text);
                                    if (needsToBeChecked.length > 0) {
                                        const treeToCheck = forest.getByUri(uri);
                                        if (treeToCheck && treeToCheck.writeable) {
                                            needsToBeChecked.forEach((a) => {
                                                switch (a.type) {
                                                    case "Module": {
                                                        const importNameNode = treeUtils_1.TreeUtils.findImportNameNode(treeToCheck.tree, a.alias);
                                                        if (importNameNode) {
                                                            references.push({ node: importNameNode, uri });
                                                        }
                                                        break;
                                                    }
                                                    default:
                                                        break;
                                                }
                                            });
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "FunctionParameter":
                        if (refSourceTree.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.uri,
                            });
                            const valueDeclaration = treeUtils_1.TreeUtils.findParentOfType("function_declaration_left", definitionNode.node);
                            if (valueDeclaration &&
                                valueDeclaration.nextNamedSibling &&
                                valueDeclaration.nextNamedSibling.nextNamedSibling) {
                                const functionBody = valueDeclaration.nextNamedSibling.nextNamedSibling;
                                if (functionBody) {
                                    const parameters = this.findParameterUsage(functionBody, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "CasePattern":
                        if (refSourceTree.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.uri,
                            });
                            if (definitionNode.node.parent &&
                                definitionNode.node.parent.parent &&
                                definitionNode.node.parent.parent.parent &&
                                definitionNode.node.parent.parent.parent.lastNamedChild) {
                                const caseBody = definitionNode.node.parent.parent.parent.lastNamedChild;
                                if (caseBody) {
                                    const parameters = this.findParameterUsage(caseBody, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "AnonymousFunctionParameter":
                        if (refSourceTree.writeable) {
                            references.push({
                                node: definitionNode.node,
                                uri: definitionNode.uri,
                            });
                            if (definitionNode.node.parent &&
                                definitionNode.node.parent.parent) {
                                const anonymousFunction = definitionNode.node.parent.parent; // TODO this is due to tree sitter matching wrong
                                if (anonymousFunction) {
                                    const parameters = this.findParameterUsage(anonymousFunction, definitionNode.node.text);
                                    if (parameters) {
                                        references.push(...parameters.map((node) => {
                                            return { node, uri: definitionNode.uri };
                                        }));
                                    }
                                }
                            }
                        }
                        break;
                    case "UnionConstructor":
                        if (definitionNode.node.firstChild && moduleNameNode) {
                            const nameNode = definitionNode.node.firstChild;
                            if (refSourceTree.writeable) {
                                references.push({
                                    node: nameNode,
                                    uri: definitionNode.uri,
                                });
                                const unionConstructorCalls = treeUtils_1.TreeUtils.findUnionConstructorCalls(refSourceTree.tree, nameNode.text);
                                if (unionConstructorCalls) {
                                    references.push(...unionConstructorCalls.map((a) => {
                                        return { node: a, uri: definitionNode.uri };
                                    }));
                                }
                            }
                            for (const uri in imports.imports) {
                                if (imports.imports.hasOwnProperty(uri)) {
                                    const element = imports.imports[uri];
                                    const needsToBeChecked = element.filter((a) => uri !== definitionNode.uri &&
                                        a.fromModuleName === moduleNameNode.text &&
                                        a.type === "UnionConstructor" &&
                                        (a.alias.endsWith(`.${nameNode.text}`) ||
                                            a.alias === nameNode.text));
                                    if (needsToBeChecked.length > 0) {
                                        const treeToCheck = forest.getByUri(uri);
                                        if (treeToCheck && treeToCheck.writeable) {
                                            const unionConstructorCallsFromOtherFiles = treeUtils_1.TreeUtils.findUnionConstructorCalls(treeToCheck.tree, nameNode.text);
                                            if (unionConstructorCallsFromOtherFiles) {
                                                references.push(...unionConstructorCallsFromOtherFiles.map((node) => {
                                                    return { node, uri };
                                                }));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "FieldType":
                        {
                            const fieldName = definitionNode.node.childForFieldName("name");
                            if (fieldName) {
                                references.push({
                                    node: fieldName,
                                    uri: definitionNode.uri,
                                });
                                references.push(...this.getFieldReferences(fieldName.text, definitionNode, refSourceTree.tree, definitionNode.uri, elmWorkspace));
                                for (const uri in imports.imports) {
                                    const element = imports.imports[uri];
                                    const needsToBeChecked = element.filter((a) => uri !== definitionNode.uri &&
                                        a.fromModuleName === (moduleNameNode === null || moduleNameNode === void 0 ? void 0 : moduleNameNode.text));
                                    if (needsToBeChecked.length > 0) {
                                        const treeToCheck = forest.getByUri(uri);
                                        if (treeToCheck && treeToCheck.writeable) {
                                            references.push(...this.getFieldReferences(fieldName.text, definitionNode, treeToCheck.tree, uri, elmWorkspace));
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
        }
        return references;
    }
    static findOperator(node) {
        var _a, _b, _c;
        const functionNameNode = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(node);
        if (functionNameNode) {
            const infixRef = (_a = this.findFunctionCalls(node.tree.rootNode, functionNameNode.text)) === null || _a === void 0 ? void 0 : _a.find((ref) => { var _a, _b, _c; return ((_c = (_b = (_a = ref.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === "infix_declaration"; });
            if ((_c = (_b = infixRef === null || infixRef === void 0 ? void 0 : infixRef.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.parent) {
                return infixRef.parent.parent.parent;
            }
        }
    }
    static findFunctionCalls(node, functionName) {
        const functions = this.findAllFunctionCallsAndParameters(node);
        const result = functions
            .filter((a) => a.text === functionName)
            .map((a) => a.lastChild);
        return result.length === 0 ? undefined : result;
    }
    static findAllFunctionCallsAndParameters(node) {
        let functions = treeUtils_1.TreeUtils.descendantsOfType(node, "value_expr");
        if (functions.length > 0) {
            functions = functions
                .filter((a) => a.firstChild && a.firstChild.type === "value_qid")
                .map((a) => a.firstChild);
        }
        return functions;
    }
    static findParameterUsage(node, functionName) {
        const parameters = [
            ...this.findAllFunctionCallsAndParameters(node),
            ...this.findAllRecordBaseIdentifiers(node),
        ];
        const result = parameters.filter((a) => a.text === functionName);
        return result.length === 0 ? undefined : result;
    }
    static findAllRecordBaseIdentifiers(node) {
        return treeUtils_1.TreeUtils.descendantsOfType(node, "record_base_identifier");
    }
    static getFunctionAnnotationNameNodeFromDefinition(node) {
        if (node.parent &&
            node.parent.previousNamedSibling &&
            node.parent.previousNamedSibling.type === "type_annotation" &&
            node.parent.previousNamedSibling.firstChild &&
            node.parent.previousNamedSibling.firstChild.type ===
                "lower_case_identifier") {
            return node.parent.previousNamedSibling.firstChild;
        }
    }
    static findFieldUsages(tree, fieldName) {
        return tree.rootNode
            .descendantsOfType([
            "field",
            "field_accessor_function_expr",
            "field_access_expr",
            "record_pattern",
        ])
            .map((field) => {
            var _a;
            if (field.type === "record_pattern") {
                const lowerPattern = field.namedChildren.find((pattern) => pattern.type === "lower_pattern" && pattern.text === fieldName);
                if (lowerPattern) {
                    const declaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", lowerPattern);
                    const patternRefs = (_a = declaration === null || declaration === void 0 ? void 0 : declaration.descendantsOfType("value_qid").filter((ref) => ref.text === fieldName)) !== null && _a !== void 0 ? _a : [];
                    return [lowerPattern, ...patternRefs];
                }
            }
            return [field];
        })
            .reduce((a, b) => a.concat(b), [])
            .map((field) => treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", field))
            .filter(utils_1.Utils.notUndefinedOrNull.bind(this))
            .filter((field) => field.text === fieldName);
    }
    static getFieldReferences(fieldName, definition, tree, uri, elmWorkspace) {
        const references = [];
        const fieldUsages = References.findFieldUsages(tree, fieldName);
        fieldUsages.forEach((field) => {
            const fieldDef = treeUtils_1.TreeUtils.findDefinitionNodeByReferencingNode(field, uri, tree, elmWorkspace);
            if ((fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.node.id) === definition.node.id) {
                references.push({
                    node: field,
                    uri,
                });
            }
        });
        return references;
    }
}
exports.References = References;
//# sourceMappingURL=references.js.map