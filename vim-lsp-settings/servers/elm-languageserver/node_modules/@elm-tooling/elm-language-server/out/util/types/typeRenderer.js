"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeRenderer = void 0;
const treeUtils_1 = require("../treeUtils");
const typeInference_1 = require("./typeInference");
class TypeRenderer {
    constructor(tree, uri, imports) {
        this.tree = tree;
        this.uri = uri;
        this.imports = imports;
        this.usedVarNames = new Map();
    }
    static typeToString(t, tree, uri, imports) {
        return new TypeRenderer(tree, uri, imports).render(t);
    }
    render(t) {
        if (t.alias) {
            return this.renderUnion(typeInference_1.TUnion(t.alias.module, t.alias.name, t.alias.parameters));
        }
        switch (t.nodeType) {
            case "Unknown":
            case "InProgressBinding":
                return "unknown";
            case "Unit":
                return "()";
            case "Var":
                return this.renderVar(t);
            case "Function":
                return `${[...t.params, t.return]
                    .map((p) => p.nodeType === "Function" ? `(${this.render(p)})` : this.render(p))
                    .join(" -> ")}`;
            case "Tuple":
                return `(${t.types.map(this.render.bind(this)).join(", ")})`;
            case "Union":
                return this.renderUnion(t);
            case "Record":
            case "MutableRecord":
                return `{ ${t.baseType ? `${this.render(t.baseType)} | ` : ""}${Object.entries(t.fields)
                    .map(([field, type]) => `${field} : ${this.render(type)}`)
                    .join(", ")} }`;
        }
    }
    renderUnion(t) {
        var _a;
        if (t.module === "WebGL" && t.name === "Shader") {
            return "shader";
        }
        let type;
        if (t.params.length === 0) {
            type = t.name;
        }
        else {
            type = `${t.name} ${t.params
                .map((p) => {
                var _a, _b;
                return p.nodeType === "Function" ||
                    (p.nodeType === "Union" && p.params.length > 0) ||
                    ((_b = (_a = p.alias) === null || _a === void 0 ? void 0 : _a.parameters.length) !== null && _b !== void 0 ? _b : 0 > 0)
                    ? `(${this.render(p)})`
                    : this.render(p);
            })
                .join(" ")}`;
        }
        if (this.tree && this.uri && this.imports) {
            return `${(_a = treeUtils_1.TreeUtils.getQualifierForName(this.tree, this.uri, t.module, t.name, this.imports)) !== null && _a !== void 0 ? _a : ""}${type}`;
        }
        else {
            return type;
        }
    }
    renderVar(t) {
        var _a, _b;
        if (this.usedVarNames.has(t)) {
            return (_a = this.usedVarNames.get(t)) !== null && _a !== void 0 ? _a : "";
        }
        const takenNames = Array.from(this.usedVarNames.values());
        if (!typeInference_1.getTypeclassName(t) && takenNames.includes(t.name)) {
            const displayName = (_b = typeInference_1.getVarNames(takenNames.length + 1).find((name) => !takenNames.includes(name))) !== null && _b !== void 0 ? _b : "";
            this.usedVarNames.set(t, displayName);
            return displayName;
        }
        this.usedVarNames.set(t, t.name);
        return t.name;
    }
}
exports.TypeRenderer = TypeRenderer;
//# sourceMappingURL=typeRenderer.js.map