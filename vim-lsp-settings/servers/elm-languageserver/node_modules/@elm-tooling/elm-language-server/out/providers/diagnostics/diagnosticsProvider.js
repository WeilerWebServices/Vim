"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticsProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const __1 = require("..");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const noWorkspaceContainsError_1 = require("../../util/noWorkspaceContainsError");
const textDocumentEvents_1 = require("../../util/textDocumentEvents");
const elmMakeDiagnostics_1 = require("./elmMakeDiagnostics");
const typeInferenceDiagnostics_1 = require("./typeInferenceDiagnostics");
const astProvider_1 = require("../astProvider");
const ts_debounce_1 = require("ts-debounce");
const fileDiagnostics_1 = require("./fileDiagnostics");
let DiagnosticsProvider = class DiagnosticsProvider {
    constructor() {
        this.elmAnalyseDiagnostics = null;
        this.settings = tsyringe_1.container.resolve("Settings");
        this.clientSettings = tsyringe_1.container.resolve("ClientSettings");
        if (this.clientSettings.elmAnalyseTrigger !== "never") {
            this.elmAnalyseDiagnostics = tsyringe_1.container.resolve(__1.ElmAnalyseDiagnostics);
        }
        this.elmMakeDiagnostics = tsyringe_1.container.resolve(elmMakeDiagnostics_1.ElmMakeDiagnostics);
        this.typeInferenceDiagnostics = tsyringe_1.container.resolve(typeInferenceDiagnostics_1.TypeInferenceDiagnostics);
        this.connection = tsyringe_1.container.resolve("Connection");
        this.events = tsyringe_1.container.resolve(textDocumentEvents_1.TextDocumentEvents);
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((doc) => vscode_uri_1.URI.parse(doc.uri));
        this.workspaces = tsyringe_1.container.resolve("ElmWorkspaces");
        const astProvider = tsyringe_1.container.resolve(astProvider_1.ASTProvider);
        this.currentDiagnostics = new Map();
        // register onChange listener if settings are not on-save only
        void this.settings.getClientSettings().then(({ elmAnalyseTrigger }) => {
            this.events.on("open", (d) => this.getDiagnostics(d, true, elmAnalyseTrigger));
            this.events.on("save", (d) => this.getDiagnostics(d, true, elmAnalyseTrigger));
            this.connection.onDidChangeWatchedFiles((event) => {
                const newDeleteEvents = event.changes
                    .filter((a) => a.type === vscode_languageserver_1.FileChangeType.Deleted)
                    .map((a) => a.uri);
                newDeleteEvents.forEach((uri) => {
                    this.deleteDiagnostics(uri);
                });
            });
            if (this.elmAnalyseDiagnostics) {
                this.elmAnalyseDiagnostics.on("new-diagnostics", this.newElmAnalyseDiagnostics.bind(this));
            }
            if (elmAnalyseTrigger === "change") {
                this.events.on("change", (d) => this.getDiagnostics(d, false, elmAnalyseTrigger));
            }
            this.workspaces.forEach((workspace) => {
                workspace.getForest().treeIndex.forEach((treeContainer) => {
                    if (treeContainer.writeable) {
                        const treeDiagnostics = this.typeInferenceDiagnostics.createDiagnostics(treeContainer.tree, treeContainer.uri, workspace);
                        this.updateDiagnostics(treeContainer.uri, 3 /* TypeInference */, treeDiagnostics);
                    }
                });
            });
            astProvider.onTreeChange(({ uri, tree }) => {
                let workspace;
                try {
                    workspace = this.elmWorkspaceMatcher.getElmWorkspaceFor({ uri });
                }
                catch (error) {
                    if (error instanceof noWorkspaceContainsError_1.NoWorkspaceContainsError) {
                        this.connection.console.info(error.message);
                        return; // ignore file that doesn't correspond to a workspace
                    }
                    throw error;
                }
                this.updateDiagnostics(uri, 3 /* TypeInference */, this.typeInferenceDiagnostics.createDiagnostics(tree, uri, workspace));
            });
        });
    }
    newElmAnalyseDiagnostics(diagnostics) {
        this.resetDiagnostics(diagnostics, 1 /* ElmAnalyse */);
        diagnostics.forEach((diagnostics, uri) => {
            this.updateDiagnostics(uri, 1 /* ElmAnalyse */, diagnostics);
        });
    }
    updateDiagnostics(uri, kind, diagnostics) {
        let didUpdate = false;
        let fileDiagnostics = this.currentDiagnostics.get(uri);
        if (fileDiagnostics) {
            didUpdate = fileDiagnostics.update(kind, diagnostics);
        }
        else if (diagnostics.length > 0) {
            fileDiagnostics = new fileDiagnostics_1.FileDiagnostics(uri);
            fileDiagnostics.update(kind, diagnostics);
            this.currentDiagnostics.set(uri, fileDiagnostics);
            didUpdate = true;
        }
        if (didUpdate) {
            const sendDiagnostics = (uri) => {
                const fileDiagnostics = this.currentDiagnostics.get(uri);
                this.connection.sendDiagnostics({
                    uri,
                    diagnostics: fileDiagnostics ? fileDiagnostics.get() : [],
                });
            };
            const sendDiagnosticsDebounced = ts_debounce_1.debounce(sendDiagnostics, 50);
            sendDiagnosticsDebounced(uri);
        }
    }
    deleteDiagnostics(uri) {
        this.currentDiagnostics.delete(uri);
        this.connection.sendDiagnostics({
            uri,
            diagnostics: [],
        });
    }
    getDiagnostics({ document }, isSaveOrOpen, elmAnalyseTrigger) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.connection.console.info(`Diagnostics were requested due to a file ${isSaveOrOpen ? "open or save" : "change"}`);
            const uri = vscode_uri_1.URI.parse(document.uri);
            const text = document.getText();
            if (isSaveOrOpen) {
                const elmMakeDiagnostics = yield this.elmMakeDiagnostics.createDiagnostics(uri);
                this.resetDiagnostics(elmMakeDiagnostics, 0 /* ElmMake */);
                elmMakeDiagnostics.forEach((diagnostics, diagnosticsUri) => {
                    this.updateDiagnostics(diagnosticsUri, 0 /* ElmMake */, diagnostics);
                });
            }
            const elmMakeDiagnosticsForCurrentFile = (_b = (_a = this.currentDiagnostics
                .get(uri.toString())) === null || _a === void 0 ? void 0 : _a.getForKind(0 /* ElmMake */)) !== null && _b !== void 0 ? _b : [];
            if (this.elmAnalyseDiagnostics &&
                elmAnalyseTrigger !== "never" &&
                (!elmMakeDiagnosticsForCurrentFile ||
                    (elmMakeDiagnosticsForCurrentFile &&
                        elmMakeDiagnosticsForCurrentFile.length === 0))) {
                yield this.elmAnalyseDiagnostics.updateFile(uri, text);
            }
        });
    }
    resetDiagnostics(diagnosticList, diagnosticKind) {
        this.currentDiagnostics.forEach((fileDiagnostics, diagnosticsUri) => {
            if (!diagnosticList.has(diagnosticsUri) &&
                fileDiagnostics.getForKind(diagnosticKind).length > 0) {
                diagnosticList.set(diagnosticsUri, []);
            }
        });
    }
};
DiagnosticsProvider = __decorate([
    tsyringe_1.injectable(),
    __metadata("design:paramtypes", [])
], DiagnosticsProvider);
exports.DiagnosticsProvider = DiagnosticsProvider;
//# sourceMappingURL=diagnosticsProvider.js.map