"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeReplacement = void 0;
const typeInference_1 = require("./typeInference");
class TypeReplacement {
    constructor(replacements, freshen, keepRecordsMutable, varsToRemainRigid) {
        this.freshen = freshen;
        this.keepRecordsMutable = keepRecordsMutable;
        this.varsToRemainRigid = varsToRemainRigid;
        this.replacements = new Map();
        replacements.forEach((value, key) => {
            this.replacements.set(key, [false, value]);
        });
    }
    static replace(type, replacements, keepRecordsMutable = false, varsToRemainRigid) {
        if (!varsToRemainRigid && replacements.size === 0) {
            return type;
        }
        return new TypeReplacement(replacements, false, keepRecordsMutable, varsToRemainRigid).replace(type);
    }
    static freshenVars(type) {
        return new TypeReplacement(new Map(), true, false).replace(type);
    }
    static flexify(type) {
        return new TypeReplacement(new Map(), false, false, []).replace(type);
    }
    static freeze(type) {
        var _a, _b, _c;
        switch (type.nodeType) {
            case "Tuple":
                type.types.forEach(this.freeze.bind(this));
                break;
            case "Record":
            case "MutableRecord":
                (_b = (_a = type.baseType) === null || _a === void 0 ? void 0 : _a.fieldReferences) === null || _b === void 0 ? void 0 : _b.freeze();
                for (const field in type.fields) {
                    this.freeze(type.fields[field]);
                }
                type.fieldReferences.freeze();
                break;
            case "Union":
                type.params.forEach(this.freeze.bind(this));
                break;
            case "Function":
                this.freeze(type.return);
                type.params.forEach(this.freeze.bind(this));
                break;
        }
        (_c = type.alias) === null || _c === void 0 ? void 0 : _c.parameters.forEach(TypeReplacement.freeze.bind(this));
    }
    replace(type) {
        var _a;
        switch (type.nodeType) {
            case "Var":
                return (_a = this.getReplacement(type)) !== null && _a !== void 0 ? _a : type;
            case "Function":
                return this.replaceFunction(type);
            case "Union":
                return this.replaceUnion(type);
            case "Tuple":
                return this.replaceTuple(type);
            case "Record":
                return this.replaceRecord(type.fields, type.fieldReferences, false, type.baseType, type.alias);
            case "MutableRecord":
                return this.replaceRecord(type.fields, type.fieldReferences, true, type.baseType);
            case "Unit":
            case "InProgressBinding":
                return type;
            case "Unknown":
                return {
                    nodeType: "Unknown",
                    alias: this.replaceAlias(type.alias),
                };
        }
    }
    replaceAlias(alias) {
        if (alias) {
            return Object.assign(Object.assign({}, alias), { parameters: alias.parameters.map((param) => this.replace(param)) });
        }
    }
    replaceTuple(type) {
        return typeInference_1.TTuple(type.types.map((t) => this.replace(t)), this.replaceAlias(type.alias));
    }
    replaceFunction(type) {
        const params = type.params.map((param) => this.replace(param));
        return typeInference_1.uncurryFunction(typeInference_1.TFunction(params, this.replace(type.return), this.replaceAlias(type.alias)));
    }
    replaceUnion(type) {
        if (type.params.length === 0 && !type.alias) {
            return type;
        }
        const params = type.params.map((param) => this.replace(param));
        return typeInference_1.TUnion(type.module, type.name, params, this.replaceAlias(type.alias));
    }
    replaceRecord(fields, fieldReferences, wasMutable, baseType, alias) {
        var _a, _b, _c;
        const oldBase = !baseType || baseType.nodeType !== "Var"
            ? undefined
            : this.getReplacement(baseType);
        let newBase = oldBase;
        if ((oldBase === null || oldBase === void 0 ? void 0 : oldBase.nodeType) === "Record") {
            newBase = oldBase.baseType;
        }
        else if (!oldBase) {
            if ((baseType === null || baseType === void 0 ? void 0 : baseType.nodeType) === "MutableRecord" && !this.keepRecordsMutable) {
                newBase = this.replace(baseType);
            }
            else {
                newBase = baseType;
            }
        }
        const baseFields = (_b = (_a = oldBase) === null || _a === void 0 ? void 0 : _a.fields) !== null && _b !== void 0 ? _b : [];
        const baseFieldRefs = (_c = oldBase) === null || _c === void 0 ? void 0 : _c.fieldReferences;
        const newFields = {};
        for (const field in baseFields) {
            newFields[field] = baseFields[field];
        }
        for (const field in fields) {
            newFields[field] = this.replace(fields[field]);
        }
        let newFieldReferences;
        if (!baseFieldRefs || baseFieldRefs.isEmpty()) {
            newFieldReferences = fieldReferences;
        }
        else if (fieldReferences.frozen) {
            newFieldReferences = fieldReferences.plus(baseFieldRefs);
        }
        else {
            fieldReferences.addAll(baseFieldRefs);
            newFieldReferences = fieldReferences;
        }
        if (wasMutable && this.keepRecordsMutable) {
            return typeInference_1.TMutableRecord(newFields, newBase, newFieldReferences);
        }
        else {
            return typeInference_1.TRecord(newFields, newBase, this.replaceAlias(alias), newFieldReferences);
        }
    }
    getReplacement(key) {
        const replacement = this.replacements.get(key);
        if (!replacement) {
            if (this.freshen || this.varsToRemainRigid) {
                if (key.rigid &&
                    (!this.varsToRemainRigid || this.varsToRemainRigid.includes(key))) {
                    return undefined;
                }
                else {
                    const newVar = typeInference_1.TVar(key.name);
                    this.replacements.set(key, [true, newVar]);
                    return newVar;
                }
            }
            return undefined;
        }
        const hasBeenAccessed = replacement[0];
        const storedType = replacement[1];
        if (hasBeenAccessed) {
            return storedType;
        }
        const replacedType = this.replace(storedType);
        this.replacements.set(key, [true, replacedType]);
        return replacedType;
    }
}
exports.TypeReplacement = TypeReplacement;
//# sourceMappingURL=typeReplacement.js.map