"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeUtils = exports.flatMap = void 0;
const utils_1 = require("./utils");
const positionUtil_1 = require("../positionUtil");
const typeInference_1 = require("./types/typeInference");
const functionNameRegex = new RegExp("[a-zA-Z0-9_]+");
function flatMap(array, callback) {
    const flattend = [];
    for (let i = 0; i < array.length; i++) {
        const elementArray = callback(array[i], i, array);
        for (const el of elementArray) {
            flattend.push(el);
        }
    }
    return flattend;
}
exports.flatMap = flatMap;
class TreeUtils {
    static getModuleNameNode(tree) {
        const moduleDeclaration = this.findModuleDeclaration(tree);
        if (moduleDeclaration) {
            return this.findFirstNamedChildOfType("upper_case_qid", moduleDeclaration);
        }
    }
    static getModuleExposingListNodes(tree) {
        const moduleNode = TreeUtils.findModuleDeclaration(tree);
        if (moduleNode) {
            return [
                ...TreeUtils.descendantsOfType(moduleNode, "exposed_value"),
                ...TreeUtils.descendantsOfType(moduleNode, "exposed_type"),
            ];
        }
        return [];
    }
    static getModuleNameAndExposing(tree) {
        var _a, _b, _c, _d;
        const moduleDeclaration = this.findModuleDeclaration(tree);
        if (moduleDeclaration) {
            const moduleName = this.findFirstNamedChildOfType("upper_case_qid", moduleDeclaration);
            const exposingList = this.findFirstNamedChildOfType("exposing_list", moduleDeclaration);
            if (exposingList) {
                const exposed = [];
                if (TreeUtils.findFirstNamedChildOfType("double_dot", exposingList)) {
                    if (moduleName) {
                        (_a = TreeUtils.descendantsOfType(tree.rootNode, "value_declaration")) === null || _a === void 0 ? void 0 : _a.forEach((elmFunction) => {
                            const declaration = TreeUtils.findFirstNamedChildOfType("function_declaration_left", elmFunction);
                            if (declaration && declaration.firstNamedChild) {
                                const functionName = declaration.firstNamedChild.text;
                                exposed.push({
                                    name: functionName,
                                    syntaxNode: declaration,
                                    type: "Function",
                                });
                            }
                        });
                        (_b = TreeUtils.findAllNamedChildrenOfType("port_annotation", tree.rootNode)) === null || _b === void 0 ? void 0 : _b.forEach((elmPort) => {
                            if (elmPort.children[1].text) {
                                exposed.push({
                                    name: elmPort.children[1].text,
                                    syntaxNode: elmPort,
                                    type: "Port",
                                });
                            }
                        });
                        (_c = this.findAllTypeAliasDeclarations(tree)) === null || _c === void 0 ? void 0 : _c.forEach((typeAlias) => {
                            const name = TreeUtils.findFirstNamedChildOfType("upper_case_identifier", typeAlias);
                            if (name) {
                                exposed.push({
                                    exposedUnionConstructors: undefined,
                                    name: name.text,
                                    syntaxNode: typeAlias,
                                    type: "TypeAlias",
                                });
                            }
                        });
                        (_d = this.findAllTypeDeclarations(tree)) === null || _d === void 0 ? void 0 : _d.forEach((typeDeclaration) => {
                            const unionConstructors = [];
                            TreeUtils.descendantsOfType(typeDeclaration, "union_variant").forEach((variant) => {
                                const name = TreeUtils.findFirstNamedChildOfType("upper_case_identifier", variant);
                                if (name && name.parent) {
                                    unionConstructors.push({
                                        name: name.text,
                                        syntaxNode: name.parent,
                                    });
                                }
                            });
                            const typeDeclarationName = TreeUtils.findFirstNamedChildOfType("upper_case_identifier", typeDeclaration);
                            if (typeDeclarationName) {
                                exposed.push({
                                    exposedUnionConstructors: unionConstructors,
                                    name: typeDeclarationName.text,
                                    syntaxNode: typeDeclaration,
                                    type: "Type",
                                });
                            }
                        });
                        return { moduleName: moduleName.text, exposing: exposed };
                    }
                }
                else {
                    const exposedOperators = TreeUtils.descendantsOfType(exposingList, "operator_identifier");
                    for (const value of exposedOperators) {
                        const functionNode = this.findOperator(tree, value.text);
                        if (functionNode) {
                            exposed.push({
                                exposedUnionConstructors: undefined,
                                name: value.text,
                                syntaxNode: functionNode,
                                type: "Operator",
                            });
                        }
                    }
                    const exposedValues = TreeUtils.descendantsOfType(exposingList, "exposed_value");
                    const exposedValuesText = exposedValues.map((a) => a.text);
                    exposed.push(...this.findExposedTopLevelFunctions(tree, exposedValuesText));
                    exposed.push(...this.findExposedTopLevelPorts(tree, exposedValuesText));
                    const exposedTypes = TreeUtils.descendantsOfType(exposingList, "exposed_type");
                    for (const value of exposedTypes) {
                        const doubleDot = TreeUtils.descendantsOfType(value, "double_dot");
                        if (doubleDot.length > 0) {
                            const name = TreeUtils.findFirstNamedChildOfType("upper_case_identifier", value);
                            if (name) {
                                const typeDeclaration = this.findTypeDeclaration(tree, name.text);
                                if (typeDeclaration) {
                                    const unionConstructors = [];
                                    TreeUtils.descendantsOfType(typeDeclaration, "union_variant").forEach((variant) => {
                                        const unionConstructorName = TreeUtils.findFirstNamedChildOfType("upper_case_identifier", variant);
                                        if (unionConstructorName && unionConstructorName.parent) {
                                            unionConstructors.push({
                                                name: unionConstructorName.text,
                                                syntaxNode: unionConstructorName.parent,
                                            });
                                        }
                                    });
                                    exposed.push({
                                        exposedUnionConstructors: unionConstructors,
                                        name: name.text,
                                        syntaxNode: typeDeclaration,
                                        type: "Type",
                                    });
                                }
                            }
                        }
                        else {
                            const typeNode = this.findTypeDeclaration(tree, value.text);
                            if (typeNode) {
                                exposed.push({
                                    exposedUnionConstructors: undefined,
                                    name: value.text,
                                    syntaxNode: typeNode,
                                    type: "Type",
                                });
                            }
                            else {
                                const typeAliasNode = this.findTypeAliasDeclaration(tree, value.text);
                                if (typeAliasNode) {
                                    exposed.push({
                                        exposedUnionConstructors: undefined,
                                        name: value.text,
                                        syntaxNode: typeAliasNode,
                                        type: "TypeAlias",
                                    });
                                }
                            }
                        }
                    }
                    if (moduleName) {
                        return { moduleName: moduleName.text, exposing: exposed };
                    }
                }
            }
        }
    }
    static findFirstNamedChildOfType(type, node) {
        return node.children.find((child) => child.type === type);
    }
    static findAllNamedChildrenOfType(type, node) {
        const result = Array.isArray(type)
            ? node.children.filter((child) => type.includes(child.type))
            : node.children.filter((child) => child.type === type);
        return result.length === 0 ? undefined : result;
    }
    static findExposedFunctionNode(node, functionName) {
        if (node) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", node);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return undefined;
                }
            }
            const descendants = TreeUtils.descendantsOfType(node, "exposed_value");
            return descendants.find((desc) => desc.text === functionName);
        }
    }
    static isExposedFunction(tree, functionName) {
        const module = this.findModuleDeclaration(tree);
        if (module) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", module);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return true;
                }
            }
            const descendants = TreeUtils.descendantsOfType(module, "exposed_value");
            return descendants.some((desc) => desc.text === functionName);
        }
        return false;
    }
    static findExposedTypeOrTypeAliasNode(node, typeName) {
        if (node) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", node);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return undefined;
                }
            }
            const descendants = TreeUtils.descendantsOfType(node, "exposed_type");
            const match = descendants.find((desc) => desc.text.startsWith(typeName));
            if (match && match.firstNamedChild) {
                return match.firstNamedChild;
            }
        }
        return undefined;
    }
    static isExposedTypeOrTypeAlias(tree, typeName) {
        const module = this.findModuleDeclaration(tree);
        if (module) {
            const exposingList = this.findFirstNamedChildOfType("exposing_list", module);
            if (exposingList) {
                const doubleDot = this.findFirstNamedChildOfType("double_dot", exposingList);
                if (doubleDot) {
                    return true;
                }
            }
            const descendants = TreeUtils.descendantsOfType(module, "exposed_type");
            return descendants.some((desc) => desc.text.startsWith(typeName));
        }
        return false;
    }
    static findUnionConstructor(tree, unionConstructorName) {
        const unionVariants = TreeUtils.descendantsOfType(tree.rootNode, "union_variant");
        if (unionVariants.length > 0) {
            return unionVariants.find((a) => a.firstChild !== null &&
                a.firstChild.type === "upper_case_identifier" &&
                a.firstChild.text === unionConstructorName);
        }
    }
    static findUnionConstructorCalls(tree, unionConstructorName) {
        const upperCaseQid = TreeUtils.descendantsOfType(tree.rootNode, "upper_case_qid");
        if (upperCaseQid.length > 0) {
            const result = upperCaseQid.filter((a) => a.firstChild !== null &&
                a.firstChild.type === "upper_case_identifier" &&
                a.firstChild.text === unionConstructorName &&
                a.parent &&
                a.parent.type !== "type_ref");
            return result.length === 0 ? undefined : result;
        }
    }
    static findLetFunctionNodeDefinition(syntaxNode, functionName) {
        var _a;
        if (((_a = syntaxNode.parent) === null || _a === void 0 ? void 0 : _a.type) === "let_in_expr") {
            const foundFunction = this.findFunction(syntaxNode.parent, functionName, false);
            if (foundFunction) {
                return foundFunction;
            }
        }
        if (syntaxNode.parent) {
            return this.findLetFunctionNodeDefinition(syntaxNode.parent, functionName);
        }
    }
    static findFunction(syntaxNode, functionName, onlySearchTopLevel = true) {
        var _a;
        const functions = onlySearchTopLevel
            ? syntaxNode.children.filter((a) => a.type === "value_declaration")
            : syntaxNode.descendantsOfType("value_declaration");
        let ret;
        if (functions) {
            ret = functions
                .map((elmFunction) => TreeUtils.findFirstNamedChildOfType("function_declaration_left", elmFunction))
                .find((declaration) => {
                if (declaration && declaration.firstNamedChild) {
                    return functionName === declaration.firstNamedChild.text;
                }
            });
            if (!ret) {
                for (const elmFunction of functions) {
                    const pattern = TreeUtils.findFirstNamedChildOfType("pattern", elmFunction);
                    if (pattern) {
                        ret = (_a = pattern
                            .descendantsOfType("lower_pattern")
                            .find((a) => functionName === a.text)) !== null && _a !== void 0 ? _a : undefined;
                        if (ret) {
                            break;
                        }
                    }
                }
            }
            return ret;
        }
    }
    static findPort(tree, portName) {
        var _a;
        return (_a = TreeUtils.findAllNamedChildrenOfType("port_annotation", tree.rootNode)) === null || _a === void 0 ? void 0 : _a.find((node) => node.children.length > 1 &&
            node.children[1].type === "lower_case_identifier" &&
            node.children[1].text === portName);
    }
    static findOperator(tree, operatorName) {
        const infixDeclarations = this.findAllNamedChildrenOfType("infix_declaration", tree.rootNode);
        if (infixDeclarations) {
            const operatorNode = infixDeclarations.find((a) => {
                const operator = TreeUtils.findFirstNamedChildOfType("operator_identifier", a);
                if (operator) {
                    return operator.text === operatorName;
                }
                return false;
            });
            if (operatorNode) {
                const functionReference = TreeUtils.findFirstNamedChildOfType("value_expr", operatorNode);
                if (functionReference) {
                    return this.findFunction(tree.rootNode, functionReference.text);
                }
            }
        }
    }
    static findTypeDeclaration(tree, typeName) {
        const types = this.findAllTypeDeclarations(tree);
        if (types) {
            return types.find((a) => a.children.length > 1 &&
                a.children[1].type === "upper_case_identifier" &&
                a.children[1].text === typeName);
        }
    }
    static findModuleDeclaration(tree) {
        return this.findFirstNamedChildOfType("module_declaration", tree.rootNode);
    }
    static findTypeAliasDeclaration(tree, typeAliasName) {
        const typeAliases = this.findAllTypeAliasDeclarations(tree);
        if (typeAliases) {
            return typeAliases.find((a) => a.children.length > 2 &&
                a.children[2].type === "upper_case_identifier" &&
                a.children[2].text === typeAliasName);
        }
    }
    static findAllTopLevelFunctionDeclarations(tree) {
        const result = tree.rootNode.children.filter((a) => a.type === "value_declaration");
        return result.length === 0 ? undefined : result;
    }
    static findAllTopLevelFunctionDeclarationsWithoutTypeAnnotation(tree) {
        const result = tree.rootNode.children.filter((a) => {
            var _a;
            return a.type === "value_declaration" &&
                ((_a = a.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) !== "type_annotation";
        });
        return result.length === 0 ? undefined : result;
    }
    static findAllTypeOrTypeAliasCalls(tree) {
        const result = [];
        const typeRefs = TreeUtils.descendantsOfType(tree.rootNode, "type_ref");
        if (typeRefs.length > 0) {
            typeRefs.forEach((a) => {
                if (a.firstChild &&
                    a.firstChild.type === "upper_case_qid" &&
                    a.firstChild.firstChild) {
                    result.push(a.firstChild);
                }
            });
        }
        return result.length === 0 ? undefined : result;
    }
    static getFunctionNameNodeFromDefinition(node) {
        if (node.type === "lower_case_identifier") {
            return node;
        }
        const declaration = node.type == "function_declaration_left"
            ? node
            : TreeUtils.findFirstNamedChildOfType("function_declaration_left", node);
        if (declaration && declaration.firstNamedChild) {
            return declaration.firstNamedChild;
        }
    }
    static getTypeOrTypeAliasNameNodeFromDefinition(node) {
        return TreeUtils.findFirstNamedChildOfType("upper_case_identifier", node);
    }
    static findTypeOrTypeAliasCalls(tree, typeOrTypeAliasName) {
        const typeOrTypeAliasNodes = this.findAllTypeOrTypeAliasCalls(tree);
        if (typeOrTypeAliasNodes) {
            const result = typeOrTypeAliasNodes.filter((a) => {
                return a.text === typeOrTypeAliasName;
            });
            return result.length === 0 ? undefined : result;
        }
    }
    static findAllTypeDeclarations(tree) {
        return this.findAllNamedChildrenOfType("type_declaration", tree.rootNode);
    }
    static findAllTypeAliasDeclarations(tree) {
        return this.findAllNamedChildrenOfType("type_alias_declaration", tree.rootNode);
    }
    static findUppercaseQidNode(tree, nodeAtPosition) {
        var _a, _b, _c, _d, _e, _f;
        let definitionNode = this.findTypeAliasDeclaration(tree, nodeAtPosition.text);
        if (definitionNode && ((_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.type) !== "union_pattern") {
            const isRecordAlias = ((_c = (_b = TreeUtils.findFirstNamedChildOfType("type_expression", definitionNode)) === null || _b === void 0 ? void 0 : _b.firstNamedChild) === null || _c === void 0 ? void 0 : _c.type) === "record_type";
            // Check for record constructor usage
            if (((_d = nodeAtPosition.parent) === null || _d === void 0 ? void 0 : _d.type) !== "value_expr" || isRecordAlias) {
                return { node: definitionNode, nodeType: "TypeAlias" };
            }
        }
        if (TreeUtils.findParentOfType("type_ref", nodeAtPosition) ||
            ((_e = nodeAtPosition.parent) === null || _e === void 0 ? void 0 : _e.type) === "type_declaration" ||
            ((_f = nodeAtPosition.parent) === null || _f === void 0 ? void 0 : _f.type) === "exposed_type") {
            definitionNode = this.findTypeDeclaration(tree, nodeAtPosition.text);
            if (definitionNode) {
                return { node: definitionNode, nodeType: "Type" };
            }
        }
        else {
            definitionNode = this.findUnionConstructor(tree, nodeAtPosition.text);
            if (definitionNode) {
                return { node: definitionNode, nodeType: "UnionConstructor" };
            }
        }
    }
    static findDefinitionNodeByReferencingNode(nodeAtPosition, uri, tree, elmWorkspace) {
        const definition = this.findDefinitionNodeByReferencingNodeShallow(nodeAtPosition, uri, tree, elmWorkspace);
        if ((definition === null || definition === void 0 ? void 0 : definition.node.type) === "lower_pattern" &&
            definition.node.firstNamedChild) {
            const innerDefinition = this.findDefinitionNodeByReferencingNodeShallow(definition.node.firstNamedChild, uri, tree, elmWorkspace);
            if (innerDefinition) {
                return innerDefinition;
            }
        }
        return definition;
    }
    static findDefinitionNodeByReferencingNodeShallow(nodeAtPosition, uri, tree, elmWorkspace) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;
        const imports = elmWorkspace.getImports();
        const forest = elmWorkspace.getForest();
        if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "upper_case_qid" &&
            nodeAtPosition.parent.previousNamedSibling &&
            nodeAtPosition.parent.previousNamedSibling.type === "module") {
            const moduleNode = nodeAtPosition.parent.parent;
            if (moduleNode) {
                return {
                    node: moduleNode,
                    nodeType: "Module",
                    uri,
                };
            }
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "upper_case_qid" &&
            nodeAtPosition.parent.previousNamedSibling &&
            nodeAtPosition.parent.previousNamedSibling.type === "import") {
            const upperCaseQid = nodeAtPosition.parent;
            const definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "Module", imports);
            if (definitionFromOtherFile) {
                return {
                    node: definitionFromOtherFile.node,
                    nodeType: "Module",
                    uri: definitionFromOtherFile.fromUri,
                };
            }
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "function_declaration_left") {
            const definitionNode = nodeAtPosition.parent.parent &&
                nodeAtPosition.parent.parent.parent &&
                nodeAtPosition.parent.parent.parent.type === "let_in_expr"
                ? this.findFunction(nodeAtPosition.parent.parent.parent, nodeAtPosition.text, false)
                : this.findFunction(tree.rootNode, nodeAtPosition.text);
            if (definitionNode) {
                return {
                    node: definitionNode,
                    nodeType: "Function",
                    uri,
                };
            }
        }
        else if ((nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "exposed_value" &&
            nodeAtPosition.parent.parent &&
            nodeAtPosition.parent.parent.parent &&
            nodeAtPosition.parent.parent.parent.type === "module_declaration") ||
            (nodeAtPosition.parent &&
                nodeAtPosition.parent.type === "type_annotation")) {
            const definitionNode = TreeUtils.findFunction(tree.rootNode, nodeAtPosition.text);
            if (definitionNode) {
                return {
                    node: definitionNode,
                    nodeType: "Function",
                    uri,
                };
            }
        }
        else if ((nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "exposed_type" &&
            nodeAtPosition.parent.parent &&
            nodeAtPosition.parent.parent.parent &&
            nodeAtPosition.parent.parent.parent.type === "module_declaration") ||
            (nodeAtPosition.previousNamedSibling &&
                (nodeAtPosition.previousNamedSibling.type === "type" ||
                    nodeAtPosition.previousNamedSibling.type === "alias"))) {
            const definitionNode = TreeUtils.findUppercaseQidNode(tree, nodeAtPosition);
            if (definitionNode) {
                return {
                    node: definitionNode.node,
                    nodeType: definitionNode.nodeType,
                    uri,
                };
            }
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "exposed_value" &&
            nodeAtPosition.parent.parent &&
            nodeAtPosition.parent.parent.parent &&
            nodeAtPosition.parent.parent.parent.type === "import_clause") {
            const definitionFromOtherFile = this.findImportFromImportList(uri, nodeAtPosition.text, "Function", imports);
            if (definitionFromOtherFile) {
                return {
                    node: definitionFromOtherFile.node,
                    nodeType: "Function",
                    uri: definitionFromOtherFile.fromUri,
                };
            }
            const portFromOtherFile = this.findImportFromImportList(uri, nodeAtPosition.text, "Port", imports);
            if (portFromOtherFile) {
                return {
                    node: portFromOtherFile.node.namedChildren[1],
                    nodeType: "Port",
                    uri: portFromOtherFile.fromUri,
                };
            }
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "exposed_type" &&
            nodeAtPosition.parent.parent &&
            nodeAtPosition.parent.parent.parent &&
            nodeAtPosition.parent.parent.parent.type === "import_clause") {
            const upperCaseQid = nodeAtPosition;
            let definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "Type", imports);
            if (definitionFromOtherFile) {
                return {
                    node: definitionFromOtherFile.node,
                    nodeType: "Type",
                    uri: definitionFromOtherFile.fromUri,
                };
            }
            definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "TypeAlias", imports);
            if (definitionFromOtherFile) {
                return {
                    node: definitionFromOtherFile.node,
                    nodeType: "TypeAlias",
                    uri: definitionFromOtherFile.fromUri,
                };
            }
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "union_variant") {
            const definitionNode = nodeAtPosition.parent;
            return {
                node: definitionNode,
                nodeType: "UnionConstructor",
                uri,
            };
        }
        else if (nodeAtPosition.parent &&
            nodeAtPosition.parent.type === "upper_case_qid") {
            const upperCaseQid = nodeAtPosition.parent;
            const definitionNode = TreeUtils.findUppercaseQidNode(tree, upperCaseQid);
            if (((_c = (_b = (_a = nodeAtPosition.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent) === null || _c === void 0 ? void 0 : _c.type) === "pattern" &&
                (definitionNode === null || definitionNode === void 0 ? void 0 : definitionNode.nodeType) === "TypeAlias") {
                return;
            }
            let definitionFromOtherFile;
            if (!definitionNode ||
                (definitionNode.nodeType === "UnionConstructor" &&
                    ((_d = upperCaseQid.parent) === null || _d === void 0 ? void 0 : _d.type) === "type_ref")) {
                // Make sure the next node is a dot, or else it isn't a Module
                if (((_e = TreeUtils.nextNode(nodeAtPosition)) === null || _e === void 0 ? void 0 : _e.type) === "dot") {
                    const endPos = upperCaseQid.text.indexOf(nodeAtPosition.text) +
                        nodeAtPosition.text.length;
                    const moduleNameOrAlias = nodeAtPosition.parent.text.substring(0, endPos);
                    const moduleName = (_g = (_f = TreeUtils.findImportNameNode(tree, moduleNameOrAlias)) === null || _f === void 0 ? void 0 : _f.text) !== null && _g !== void 0 ? _g : moduleNameOrAlias;
                    definitionFromOtherFile = this.findImportFromImportList(uri, moduleName, "Module", imports);
                    if (definitionFromOtherFile) {
                        return {
                            node: definitionFromOtherFile.node,
                            nodeType: "Module",
                            uri: definitionFromOtherFile.fromUri,
                        };
                    }
                }
                if (TreeUtils.findParentOfType("type_ref", upperCaseQid) ||
                    ((_h = upperCaseQid.parent) === null || _h === void 0 ? void 0 : _h.type) === "exposed_type") {
                    definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "Type", imports);
                    if (definitionFromOtherFile) {
                        return {
                            node: definitionFromOtherFile.node,
                            nodeType: "Type",
                            uri: definitionFromOtherFile.fromUri,
                        };
                    }
                }
                else {
                    definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "UnionConstructor", imports);
                    if (definitionFromOtherFile) {
                        return {
                            node: definitionFromOtherFile.node,
                            nodeType: "UnionConstructor",
                            uri: definitionFromOtherFile.fromUri,
                        };
                    }
                }
                definitionFromOtherFile = this.findImportFromImportList(uri, upperCaseQid.text, "TypeAlias", imports);
                if (definitionFromOtherFile) {
                    if (((_l = (_k = (_j = nodeAtPosition.parent) === null || _j === void 0 ? void 0 : _j.parent) === null || _k === void 0 ? void 0 : _k.parent) === null || _l === void 0 ? void 0 : _l.type) === "pattern" &&
                        (definitionNode === null || definitionNode === void 0 ? void 0 : definitionNode.nodeType) === "TypeAlias") {
                        return;
                    }
                    return {
                        node: definitionFromOtherFile.node,
                        nodeType: "TypeAlias",
                        uri: definitionFromOtherFile.fromUri,
                    };
                }
                definitionFromOtherFile = this.findImportFromImportList(uri, (_o = (_m = TreeUtils.findImportNameNode(tree, upperCaseQid.text)) === null || _m === void 0 ? void 0 : _m.text) !== null && _o !== void 0 ? _o : upperCaseQid.text, "Module", imports);
                if (definitionFromOtherFile) {
                    return {
                        node: definitionFromOtherFile.node,
                        nodeType: "Module",
                        uri: definitionFromOtherFile.fromUri,
                    };
                }
            }
            if (definitionNode) {
                return {
                    node: definitionNode.node,
                    nodeType: definitionNode.nodeType,
                    uri,
                };
            }
        }
        else if (((_p = nodeAtPosition.parent) === null || _p === void 0 ? void 0 : _p.type) === "lower_pattern" &&
            ((_q = nodeAtPosition.parent.parent) === null || _q === void 0 ? void 0 : _q.type) === "record_pattern") {
            const type = typeInference_1.findType(nodeAtPosition.parent.parent, uri, elmWorkspace);
            return TreeUtils.findFieldReference(type, nodeAtPosition.text, forest);
        }
        else if (nodeAtPosition.parent &&
            (nodeAtPosition.parent.type === "value_qid" ||
                nodeAtPosition.parent.type === "lower_pattern" ||
                nodeAtPosition.parent.type === "record_base_identifier")) {
            let nodeAtPositionText = nodeAtPosition.text;
            if (nodeAtPosition.parent.type === "value_qid") {
                nodeAtPositionText = nodeAtPosition.parent.text;
            }
            const caseOfParameter = this.findCaseOfParameterDefinition(nodeAtPosition, nodeAtPositionText);
            if (caseOfParameter) {
                return {
                    node: caseOfParameter,
                    nodeType: "CasePattern",
                    uri,
                };
            }
            const anonymousFunctionDefinition = this.findAnonymousFunctionParameterDefinition(nodeAtPosition, nodeAtPositionText);
            if (anonymousFunctionDefinition) {
                return {
                    node: anonymousFunctionDefinition,
                    nodeType: "AnonymousFunctionParameter",
                    uri,
                };
            }
            const functionParameter = this.findFunctionParameterDefinition(nodeAtPosition, nodeAtPositionText);
            if (functionParameter) {
                return {
                    node: functionParameter,
                    nodeType: "FunctionParameter",
                    uri,
                };
            }
            const typeVariable = TreeUtils.findTypeAliasTypeVariable(nodeAtPosition, nodeAtPositionText);
            if (typeVariable) {
                return {
                    node: typeVariable,
                    nodeType: "TypeVariable",
                    uri,
                };
            }
            const letDefinitionNode = TreeUtils.findLetFunctionNodeDefinition(nodeAtPosition, nodeAtPositionText);
            if (letDefinitionNode) {
                return {
                    node: letDefinitionNode,
                    nodeType: "Function",
                    uri,
                };
            }
            const portDefinitionNode = TreeUtils.findPort(tree, nodeAtPositionText);
            if (portDefinitionNode) {
                return {
                    node: portDefinitionNode,
                    nodeType: "Port",
                    uri,
                };
            }
            const topLevelDefinitionNode = TreeUtils.findFunction(tree.rootNode, nodeAtPosition.parent.text);
            if (!topLevelDefinitionNode) {
                // Get the full module name and handle an import alias if there is one
                const endPos = nodeAtPosition.parent.text.indexOf(nodeAtPosition.text) +
                    nodeAtPosition.text.length;
                const moduleNameOrAlias = nodeAtPosition.parent.text.substring(0, endPos);
                const moduleName = (_s = (_r = TreeUtils.findImportNameNode(tree, moduleNameOrAlias)) === null || _r === void 0 ? void 0 : _r.text) !== null && _s !== void 0 ? _s : moduleNameOrAlias;
                const moduleDefinitionFromOtherFile = this.findImportFromImportList(uri, moduleName, "Module", imports);
                if (moduleDefinitionFromOtherFile) {
                    return {
                        node: moduleDefinitionFromOtherFile.node,
                        nodeType: "Module",
                        uri: moduleDefinitionFromOtherFile.fromUri,
                    };
                }
                const portDefinitionFromOtherFile = TreeUtils.findImportFromImportList(uri, nodeAtPosition.parent.text, "Port", imports);
                if (portDefinitionFromOtherFile) {
                    return {
                        node: portDefinitionFromOtherFile.node,
                        nodeType: "Port",
                        uri: portDefinitionFromOtherFile.fromUri,
                    };
                }
                const functionDefinitionFromOtherFile = TreeUtils.findImportFromImportList(uri, nodeAtPosition.parent.text, "Function", imports);
                if (functionDefinitionFromOtherFile) {
                    return {
                        node: functionDefinitionFromOtherFile.node,
                        nodeType: "Function",
                        uri: functionDefinitionFromOtherFile.fromUri,
                    };
                }
            }
            if (topLevelDefinitionNode) {
                return {
                    node: topLevelDefinitionNode,
                    nodeType: "Function",
                    uri,
                };
            }
        }
        else if (nodeAtPosition.type === "operator_identifier") {
            const definitionNode = TreeUtils.findOperator(tree, nodeAtPosition.text);
            if (!definitionNode) {
                const definitionFromOtherFile = this.findImportFromImportList(uri, nodeAtPosition.text, "Operator", imports);
                if (definitionFromOtherFile) {
                    return {
                        node: definitionFromOtherFile.node,
                        nodeType: "Operator",
                        uri: definitionFromOtherFile.fromUri,
                    };
                }
            }
            if (definitionNode) {
                return { node: definitionNode, uri, nodeType: "Operator" };
            }
        }
        else if (((_t = nodeAtPosition.parent) === null || _t === void 0 ? void 0 : _t.type) === "field_access_expr") {
            let target = (_u = nodeAtPosition.parent) === null || _u === void 0 ? void 0 : _u.childForFieldName("target");
            // Adjust for parenthesis expr. Will need to change when we handle it better in inference
            if ((target === null || target === void 0 ? void 0 : target.type) === "parenthesized_expr") {
                target = target.namedChildren[1];
            }
            if (target) {
                const type = typeInference_1.findType(target, uri, elmWorkspace);
                return TreeUtils.findFieldReference(type, nodeAtPosition.text, forest);
            }
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            ((_v = nodeAtPosition.parent) === null || _v === void 0 ? void 0 : _v.type) === "field" &&
            ((_w = nodeAtPosition.parent.parent) === null || _w === void 0 ? void 0 : _w.type) === "record_expr") {
            const type = typeInference_1.findType(nodeAtPosition.parent.parent, uri, elmWorkspace);
            return TreeUtils.findFieldReference(type, nodeAtPosition.text, forest);
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            ((_x = nodeAtPosition.parent) === null || _x === void 0 ? void 0 : _x.type) === "field_accessor_function_expr") {
            const type = typeInference_1.findType(nodeAtPosition.parent, uri, elmWorkspace);
            if (type.nodeType === "Function") {
                const paramType = type.params[0];
                return TreeUtils.findFieldReference(paramType, nodeAtPosition.text, forest);
            }
        }
        else if (nodeAtPosition.type === "lower_case_identifier" &&
            ((_y = nodeAtPosition.parent) === null || _y === void 0 ? void 0 : _y.type) === "field_type") {
            return {
                node: nodeAtPosition.parent,
                nodeType: "FieldType",
                uri,
            };
        }
        else if (nodeAtPosition.type === "upper_case_identifier" &&
            ((_z = nodeAtPosition.parent) === null || _z === void 0 ? void 0 : _z.type) === "ERROR") {
            let fullModuleName = nodeAtPosition.text;
            // Get fully qualified module name
            // Ex: nodeAtPosition.text is Attributes, we need to get Html.Attributes manually
            let currentNode = nodeAtPosition.previousNamedSibling;
            while ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type) === "dot" &&
                ((_0 = currentNode.previousNamedSibling) === null || _0 === void 0 ? void 0 : _0.type) === "upper_case_identifier") {
                fullModuleName = `${currentNode.previousNamedSibling.text}.${fullModuleName}`;
                currentNode = currentNode.previousNamedSibling.previousNamedSibling;
            }
            const definitionFromOtherFile = this.findImportFromImportList(uri, (_2 = (_1 = TreeUtils.findImportNameNode(tree, fullModuleName)) === null || _1 === void 0 ? void 0 : _1.text) !== null && _2 !== void 0 ? _2 : fullModuleName, "Module", imports);
            if (definitionFromOtherFile) {
                return {
                    node: definitionFromOtherFile.node,
                    nodeType: "Module",
                    uri: definitionFromOtherFile.fromUri,
                };
            }
        }
        const parentType = (_4 = (_3 = TreeUtils.findParentOfType("type_annotation", nodeAtPosition)) !== null && _3 !== void 0 ? _3 : TreeUtils.findParentOfType("type_declaration", nodeAtPosition)) !== null && _4 !== void 0 ? _4 : TreeUtils.findParentOfType("type_alias_declaration", nodeAtPosition);
        if ((parentType === null || parentType === void 0 ? void 0 : parentType.type) === "type_annotation") {
            const ancestorDeclarations = TreeUtils.getAllAncestorsOfType("value_declaration", parentType);
            const allAnnotations = [
                ...ancestorDeclarations
                    .map((n) => TreeUtils.getTypeAnnotation(n))
                    .filter((n) => !!n)
                    .reverse(),
                parentType,
            ];
            // Remove `flatMap` function when Node 10 is dropped
            const callback = (annotation) => annotation
                ? TreeUtils.descendantsOfType(annotation, "type_variable")
                : [];
            const allTypeVariables = allAnnotations.flatMap
                ? allAnnotations.flatMap(callback)
                : flatMap(allAnnotations, callback);
            const firstMatching = allTypeVariables.find((t) => t.text === nodeAtPosition.text);
            if (firstMatching) {
                return {
                    node: firstMatching,
                    nodeType: "TypeVariable",
                    uri,
                };
            }
        }
        else if (parentType) {
            const allTypeNames = TreeUtils.findAllNamedChildrenOfType("lower_type_name", parentType);
            const firstMatching = allTypeNames === null || allTypeNames === void 0 ? void 0 : allTypeNames.find((t) => t.text === nodeAtPosition.text);
            if (firstMatching) {
                return {
                    node: firstMatching,
                    nodeType: "TypeVariable",
                    uri,
                };
            }
        }
    }
    static findTypeAliasTypeVariable(nodeAtPosition, nodeAtPositionText) {
        const parentTypeAlias = this.findParentOfType("type_alias_declaration", nodeAtPosition);
        if (parentTypeAlias) {
            const lowerTypeNames = TreeUtils.findAllNamedChildrenOfType("lower_type_name", parentTypeAlias);
            return lowerTypeNames === null || lowerTypeNames === void 0 ? void 0 : lowerTypeNames.find((t) => t.text === nodeAtPositionText);
        }
    }
    static findFunctionParameterDefinition(node, functionParameterName) {
        if (node.parent) {
            if ((node.parent.type === "value_declaration" ||
                node.parent.type === "ERROR") &&
                node.parent.firstChild &&
                node.parent.firstChild.type === "function_declaration_left") {
                if (node.parent.firstChild) {
                    const match = this.descendantsOfType(node.parent.firstChild, "lower_pattern").find((a) => a.text === functionParameterName);
                    if (match) {
                        return match;
                    }
                    else {
                        return this.findFunctionParameterDefinition(node.parent, functionParameterName);
                    }
                }
            }
            else {
                return this.findFunctionParameterDefinition(node.parent, functionParameterName);
            }
        }
    }
    static findAnonymousFunctionParameterDefinition(node, functionParameterName) {
        const anonymousFunctionExprNodes = TreeUtils.getAllAncestorsOfType("anonymous_function_expr", node);
        const match = anonymousFunctionExprNodes
            .map((a) => { var _a; return (_a = TreeUtils.findAllNamedChildrenOfType("pattern", a)) !== null && _a !== void 0 ? _a : []; })
            .reduce((a, b) => a.concat(b), [])
            .map((pattern) => pattern.descendantsOfType("lower_pattern"))
            .reduce((a, b) => a.concat(b), [])
            .find((child) => child.text === functionParameterName);
        if (match) {
            return match;
        }
    }
    static findCaseOfParameterDefinition(node, caseParameterName) {
        if (node.parent) {
            if (node.parent.type === "case_of_branch" && node.parent.firstChild) {
                const match = node.parent.firstChild
                    .descendantsOfType("lower_pattern")
                    .find((a) => a.text === caseParameterName);
                if (match) {
                    return match;
                }
                else {
                    return this.findCaseOfParameterDefinition(node.parent, caseParameterName);
                }
            }
            else {
                return this.findCaseOfParameterDefinition(node.parent, caseParameterName);
            }
        }
    }
    static findImportFromImportList(uri, nodeName, type, imports) {
        if (imports.imports) {
            const allFileImports = imports.imports[uri];
            if (allFileImports) {
                // We prefer explicitlyExposed functions as in "import Foo exposing (Bar)" to "import Bar exposing (..)"
                const foundNode = allFileImports.find((a) => a.alias === nodeName && a.type === type && a.explicitlyExposed);
                if (foundNode) {
                    return foundNode;
                }
                else {
                    const foundNode = allFileImports.find((a) => a.alias === nodeName && a.type === type);
                    if (foundNode) {
                        return foundNode;
                    }
                }
            }
        }
    }
    static findImportClauseByName(tree, moduleName) {
        const allImports = this.findAllImportClauseNodes(tree);
        if (allImports) {
            return allImports.find((a) => a.children.length > 1 &&
                a.children[1].type === "upper_case_qid" &&
                a.children[1].text === moduleName);
        }
    }
    static getAllImportedValues(forest, tree) {
        const allImports = TreeUtils.findAllImportClauseNodes(tree);
        const allImportedValues = [];
        if (allImports) {
            allImports.forEach((importClause) => {
                var _a, _b, _c;
                const exposingList = TreeUtils.findFirstNamedChildOfType("exposing_list", importClause);
                const moduleName = (_a = TreeUtils.findFirstNamedChildOfType("upper_case_qid", importClause)) === null || _a === void 0 ? void 0 : _a.text;
                if (exposingList && moduleName) {
                    (_b = TreeUtils.findAllNamedChildrenOfType(["exposed_value", "exposed_type"], exposingList)) === null || _b === void 0 ? void 0 : _b.forEach((node) => {
                        allImportedValues.push({
                            module: moduleName,
                            value: node.text,
                        });
                        // Todo: Add exposing union constructors
                    });
                    // Handle all imports
                    if (exposingList.text === "exposing (..)") {
                        const moduleTree = forest.treeIndex.find((tree) => tree.moduleName === moduleName);
                        (_c = moduleTree === null || moduleTree === void 0 ? void 0 : moduleTree.exposing) === null || _c === void 0 ? void 0 : _c.forEach((exposed) => {
                            var _a;
                            allImportedValues.push({
                                module: moduleName,
                                value: exposed.name,
                            });
                            (_a = exposed.exposedUnionConstructors) === null || _a === void 0 ? void 0 : _a.forEach((exposedUnion) => {
                                allImportedValues.push({
                                    module: moduleName,
                                    value: exposedUnion.name,
                                });
                            });
                        });
                    }
                }
            });
        }
        return allImportedValues;
    }
    static findImportNameNode(tree, moduleName) {
        const allImports = this.findAllImportClauseNodes(tree);
        if (allImports) {
            const match = allImports.find((a) => {
                var _a;
                return (a.children.length > 1 &&
                    a.children[1].type === "upper_case_qid" &&
                    a.children[1].text === moduleName) ||
                    (a.children.length > 2 &&
                        a.children[2].type === "as_clause" &&
                        ((_a = a.children[2].lastNamedChild) === null || _a === void 0 ? void 0 : _a.text) === moduleName);
            });
            if (match) {
                return match.children[1];
            }
        }
    }
    static getTypeOrTypeAliasOfFunctionParameter(node) {
        if (node &&
            node.parent &&
            node.parent.parent &&
            node.parent.parent.parent &&
            node.parent.parent.parent.previousNamedSibling &&
            node.parent.parent.parent.previousNamedSibling.type ===
                "type_annotation" &&
            node.parent.parent.parent.previousNamedSibling.lastNamedChild) {
            const functionParameterNodes = TreeUtils.findAllNamedChildrenOfType(["pattern", "lower_pattern"], node.parent.parent);
            if (functionParameterNodes) {
                const matchIndex = functionParameterNodes.findIndex((a) => a.text === node.text);
                const typeAnnotationNodes = TreeUtils.findAllNamedChildrenOfType(["type_ref", "type_expression"], node.parent.parent.parent.previousNamedSibling.lastNamedChild);
                if (typeAnnotationNodes) {
                    return typeAnnotationNodes[matchIndex];
                }
            }
        }
    }
    static getReturnTypeOrTypeAliasOfFunctionDefinition(node) {
        var _a, _b, _c;
        if (node && ((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "type_annotation") {
            const typeAnnotationNodes = TreeUtils.descendantsOfType(node.previousNamedSibling, "type_ref");
            if (typeAnnotationNodes) {
                const type = typeAnnotationNodes[typeAnnotationNodes.length - 1];
                return (_c = (_b = type.firstNamedChild) === null || _b === void 0 ? void 0 : _b.firstNamedChild) !== null && _c !== void 0 ? _c : type;
            }
        }
    }
    static getTypeOrTypeAliasOfFunctionRecordParameter(node, tree, uri, elmWorkspace) {
        var _a, _b, _c;
        if (((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.type) === "function_call_expr" &&
            node.parent.firstNamedChild) {
            const parameterIndex = node.parent.namedChildren.map((c) => c.text).indexOf(node.text) - 1;
            const functionName = TreeUtils.descendantsOfType(node.parent.firstNamedChild, "lower_case_identifier");
            const functionDefinition = TreeUtils.findDefinitionNodeByReferencingNode(functionName[functionName.length - 1], uri, tree, elmWorkspace);
            if ((_b = functionDefinition === null || functionDefinition === void 0 ? void 0 : functionDefinition.node.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.lastNamedChild) {
                const typeAnnotationNodes = TreeUtils.findAllNamedChildrenOfType(["type_ref", "record_type"], functionDefinition.node.previousNamedSibling.lastNamedChild);
                if (typeAnnotationNodes) {
                    const typeNode = typeAnnotationNodes[parameterIndex];
                    if ((typeNode === null || typeNode === void 0 ? void 0 : typeNode.type) === "type_ref") {
                        const typeNodes = TreeUtils.descendantsOfType(typeNode, "upper_case_identifier");
                        if (typeNodes.length > 0) {
                            return (_c = TreeUtils.findDefinitionNodeByReferencingNode(typeNodes[0], uri, tree, elmWorkspace)) === null || _c === void 0 ? void 0 : _c.node;
                        }
                    }
                    else {
                        return typeNode || undefined;
                    }
                }
            }
        }
    }
    static getTypeAliasOfRecordField(node, tree, uri, elmWorkspace) {
        var _a, _b, _c;
        const fieldName = (_b = (_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.text;
        let recordType = TreeUtils.getTypeAliasOfRecord(node, tree, uri, elmWorkspace);
        while (!recordType && ((_c = node === null || node === void 0 ? void 0 : node.parent) === null || _c === void 0 ? void 0 : _c.parent)) {
            node = node.parent.parent;
            recordType = TreeUtils.getTypeAliasOfRecordField(node, tree, uri, elmWorkspace);
        }
        if (recordType) {
            const fieldTypes = TreeUtils.descendantsOfType(recordType.node, "field_type");
            const fieldNode = fieldTypes.find((a) => {
                var _a;
                return (((_a = TreeUtils.findFirstNamedChildOfType("lower_case_identifier", a)) === null || _a === void 0 ? void 0 : _a.text) === fieldName);
            });
            if (fieldNode) {
                const typeExpression = TreeUtils.findFirstNamedChildOfType("type_expression", fieldNode);
                if (typeExpression) {
                    const typeNode = TreeUtils.descendantsOfType(typeExpression, "upper_case_identifier");
                    if (typeNode.length > 0) {
                        const typeAliasNode = TreeUtils.findDefinitionNodeByReferencingNode(typeNode[0], recordType.uri, tree, elmWorkspace);
                        if (typeAliasNode) {
                            return { node: typeAliasNode.node, uri: typeAliasNode.uri };
                        }
                    }
                }
            }
        }
    }
    static getTypeAliasOfCase(type, tree, uri, elmWorkspace) {
        if (type) {
            const definitionNode = TreeUtils.findDefinitionNodeByReferencingNode(type, uri, tree, elmWorkspace);
            if (definitionNode) {
                const definitionTree = elmWorkspace
                    .getForest()
                    .getTree(definitionNode.uri);
                let aliasNode;
                if (definitionNode.nodeType === "FunctionParameter") {
                    aliasNode = TreeUtils.getTypeOrTypeAliasOfFunctionParameter(definitionNode.node);
                }
                else if (definitionNode.nodeType === "Function") {
                    aliasNode = TreeUtils.getReturnTypeOrTypeAliasOfFunctionDefinition(definitionNode.node);
                }
                else if (definitionNode.nodeType === "FieldType") {
                    aliasNode = TreeUtils.findFirstNamedChildOfType("type_expression", definitionNode.node);
                }
                else if (definitionNode.nodeType === "TypeAlias") {
                    return { node: definitionNode.node, uri: definitionNode.uri };
                }
                if (aliasNode && definitionTree) {
                    const childNode = TreeUtils.descendantsOfType(aliasNode, "upper_case_identifier");
                    if (childNode.length > 0) {
                        const typeNode = TreeUtils.findDefinitionNodeByReferencingNode(childNode[0], definitionNode.uri, definitionTree, elmWorkspace);
                        if (typeNode) {
                            return { node: typeNode.node, uri: typeNode.uri };
                        }
                    }
                }
            }
        }
    }
    static getTypeAliasOfRecord(node, tree, uri, elmWorkspace) {
        var _a, _b, _c, _d;
        if ((_a = node === null || node === void 0 ? void 0 : node.parent) === null || _a === void 0 ? void 0 : _a.parent) {
            let type = (_b = TreeUtils.findFirstNamedChildOfType("record_base_identifier", node.parent.parent)) !== null && _b !== void 0 ? _b : TreeUtils.findFirstNamedChildOfType("record_base_identifier", node.parent);
            // Handle records of function returns
            if (!type && node.parent.parent.parent) {
                type = (_d = (_c = TreeUtils.getReturnTypeOrTypeAliasOfFunctionDefinition(node.parent.parent.parent)) === null || _c === void 0 ? void 0 : _c.parent) !== null && _d !== void 0 ? _d : undefined;
            }
            if (!type) {
                type = node;
            }
            if (type) {
                const definitionNode = TreeUtils.findDefinitionNodeByReferencingNode(type.firstNamedChild ? type.firstNamedChild : type, uri, tree, elmWorkspace);
                if (definitionNode) {
                    const definitionTree = elmWorkspace
                        .getForest()
                        .getTree(definitionNode.uri);
                    let aliasNode;
                    if (definitionNode.nodeType === "FunctionParameter" &&
                        definitionNode.node.firstNamedChild) {
                        aliasNode = TreeUtils.getTypeOrTypeAliasOfFunctionParameter(definitionNode.node.firstNamedChild);
                    }
                    else if (definitionNode.nodeType === "Function") {
                        aliasNode = TreeUtils.getReturnTypeOrTypeAliasOfFunctionDefinition(definitionNode.node);
                    }
                    else if (definitionNode.nodeType === "FieldType") {
                        aliasNode = TreeUtils.findFirstNamedChildOfType("type_expression", definitionNode.node);
                    }
                    else if (definitionNode.nodeType === "TypeAlias") {
                        return { node: definitionNode.node, uri: definitionNode.uri };
                    }
                    if (aliasNode && definitionTree) {
                        const childNode = TreeUtils.descendantsOfType(aliasNode, "upper_case_identifier");
                        if (childNode.length > 0) {
                            const typeNode = TreeUtils.findDefinitionNodeByReferencingNode(childNode[0], definitionNode.uri, definitionTree, elmWorkspace);
                            if (typeNode) {
                                return { node: typeNode.node, uri: typeNode.uri };
                            }
                        }
                    }
                }
            }
        }
    }
    static getAllFieldsFromTypeAlias(node) {
        const result = [];
        if (node) {
            const fieldTypes = TreeUtils.descendantsOfType(node, "field_type");
            if (fieldTypes.length > 0) {
                fieldTypes.forEach((a) => {
                    const fieldName = TreeUtils.findFirstNamedChildOfType("lower_case_identifier", a);
                    const typeExpression = TreeUtils.findFirstNamedChildOfType("type_expression", a);
                    if (fieldName && typeExpression) {
                        result.push({ field: fieldName.text, type: typeExpression.text });
                    }
                });
            }
        }
        return result.length === 0 ? undefined : result;
    }
    static descendantsOfType(node, type) {
        return node.descendantsOfType(type);
    }
    static getNamedDescendantForPosition(node, position) {
        const previousCharColumn = position.character === 0 ? 0 : position.character - 1;
        const charBeforeCursor = node.text
            .split("\n")[position.line].substring(previousCharColumn, position.character);
        if (!functionNameRegex.test(charBeforeCursor)) {
            return node.namedDescendantForPosition({
                column: position.character,
                row: position.line,
            });
        }
        else {
            return node.namedDescendantForPosition({
                column: previousCharColumn,
                row: position.line,
            }, {
                column: position.character,
                row: position.line,
            });
        }
    }
    static findPreviousNode(node, position) {
        function nodeHasTokens(n) {
            return n.endIndex - n.startIndex !== 0;
        }
        function findRightmostChildWithTokens(childrenList, startIndex) {
            for (let i = startIndex - 1; i >= 0; i--) {
                if (nodeHasTokens(childrenList[i])) {
                    return childrenList[i];
                }
            }
        }
        function findRightmostNode(n) {
            if (n.children.length === 0) {
                return n;
            }
            const candidate = findRightmostChildWithTokens(n.children, n.children.length);
            if (candidate) {
                return findRightmostNode(candidate);
            }
        }
        const children = node.children;
        if (children.length === 0) {
            return node;
        }
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (positionUtil_1.comparePosition(position, child.endPosition) < 0) {
                const lookInPreviousChild = positionUtil_1.comparePosition(position, child.startPosition) <= 0 ||
                    !nodeHasTokens(child);
                if (lookInPreviousChild) {
                    const candidate = findRightmostChildWithTokens(children, i);
                    if (candidate) {
                        return findRightmostNode(candidate);
                    }
                }
                else {
                    return this.findPreviousNode(child, position);
                }
            }
        }
        const candidate = findRightmostChildWithTokens(children, children.length);
        if (candidate) {
            return findRightmostNode(candidate);
        }
    }
    static getNamedDescendantForLineBeforePosition(node, position) {
        const previousLine = position.line === 0 ? 0 : position.line - 1;
        return node.namedDescendantForPosition({
            column: 0,
            row: previousLine,
        });
    }
    static getNamedDescendantForLineAfterPosition(node, position) {
        const followingLine = position.line + 1;
        return node.namedDescendantForPosition({
            column: 0,
            row: followingLine,
        });
    }
    static findParentOfType(typeToLookFor, node, topLevel = false) {
        var _a;
        if (node.type === typeToLookFor &&
            (!topLevel || ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "file")) {
            return node;
        }
        if (node.parent) {
            return this.findParentOfType(typeToLookFor, node.parent, topLevel);
        }
    }
    static getLastImportNode(tree) {
        const allImportNodes = this.findAllImportClauseNodes(tree);
        if (allImportNodes === null || allImportNodes === void 0 ? void 0 : allImportNodes.length) {
            return allImportNodes[allImportNodes.length - 1];
        }
    }
    static isReferenceFullyQualified(node) {
        var _a, _b, _c;
        return (((_a = node.previousNamedSibling) === null || _a === void 0 ? void 0 : _a.type) === "dot" &&
            ((_c = (_b = node.previousNamedSibling) === null || _b === void 0 ? void 0 : _b.previousNamedSibling) === null || _c === void 0 ? void 0 : _c.type) ===
                "upper_case_identifier");
    }
    static getTypeAnnotation(valueDeclaration) {
        if ((valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.type) !== "value_declaration") {
            return;
        }
        let candidate = valueDeclaration.previousNamedSibling;
        // Skip comments
        while ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "line_comment" ||
            (candidate === null || candidate === void 0 ? void 0 : candidate.type) === "comment_block") {
            candidate = candidate.previousNamedSibling;
        }
        if ((candidate === null || candidate === void 0 ? void 0 : candidate.type) === "type_annotation") {
            return candidate;
        }
    }
    /**
     * This gets a list of all ancestors of a type
     * in order from the closest declaration up to the top level declaration
     */
    static getAllAncestorsOfType(type, node) {
        const declarations = [];
        while (node.type !== "file") {
            if (node.type === type) {
                declarations.push(node);
            }
            if (node.parent) {
                node = node.parent;
            }
            else {
                break;
            }
        }
        return declarations;
    }
    static getQualifierForName(tree, uri, module, name, imports) {
        var _a, _b;
        if (imports.imports) {
            if (imports.imports[uri]
                .filter((imp) => imp.fromModuleName === module &&
                (imp.type === "Type" ||
                    imp.type === "TypeAlias" ||
                    imp.type === "UnionConstructor"))
                .some((imp) => imp.alias === name)) {
                return "";
            }
            const moduleImport = TreeUtils.findImportClauseByName(tree, module);
            if (!moduleImport) {
                return;
            }
            const asClause = TreeUtils.findFirstNamedChildOfType("as_clause", moduleImport);
            if (asClause) {
                return `${(_b = (_a = asClause === null || asClause === void 0 ? void 0 : asClause.lastNamedChild) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : module}.`;
            }
            return `${module}.`;
        }
    }
    static findExposedTopLevelFunctions(tree, functionNamesToFind) {
        return tree.rootNode.children
            .filter((node) => node.type === "value_declaration" &&
            node.namedChildren.some((a) => a.type === "function_declaration_left"))
            .map((node) => node.namedChildren.find((child) => {
            var _a;
            return child.type === "function_declaration_left" && ((_a = child.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text);
        }))
            .filter(utils_1.Utils.notUndefined.bind(this))
            .map((node) => {
            var _a;
            return { node, text: (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text };
        })
            .filter((node) => functionNamesToFind.includes(node.text))
            .map((functionNode) => {
            return {
                exposedUnionConstructors: undefined,
                name: functionNode.text,
                syntaxNode: functionNode.node,
                type: "Function",
            };
        });
    }
    static findExposedTopLevelPorts(tree, functionNamesToFind) {
        return tree.rootNode.children
            .filter((node) => node.type === "port_annotation" &&
            node.children.length > 1 &&
            functionNamesToFind.includes(node.children[1].text))
            .map((portNode) => {
            return {
                exposedUnionConstructors: undefined,
                name: portNode.children[1].text,
                syntaxNode: portNode,
                type: "Port",
            };
        });
    }
    static findAllImportClauseNodes(tree) {
        const result = tree.rootNode.children.filter((a) => a.type === "import_clause");
        return result.length === 0 ? undefined : result;
    }
    static isIdentifier(node) {
        return (node.type === "lower_case_identifier" ||
            node.type === "upper_case_identifier");
    }
    static isImport(node) {
        var _a, _b, _c, _d, _e;
        return (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.type) === "import" ||
            ((_e = (_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.parent) === null || _d === void 0 ? void 0 : _d.firstNamedChild) === null || _e === void 0 ? void 0 : _e.type) === "import");
    }
    static nextNode(node) {
        // Move up until we have a sibling
        while (!node.nextNamedSibling && node.parent) {
            node = node.parent;
        }
        if (node.nextNamedSibling) {
            node = node.nextNamedSibling;
            // Move down the leftmost subtree
            while (node.firstNamedChild) {
                node = node.firstNamedChild;
            }
            return node;
        }
    }
    static findFieldReference(type, fieldName, forest) {
        if (type.nodeType === "Record") {
            const fieldRefs = type.fieldReferences.get(fieldName);
            if (fieldRefs.length > 0) {
                const refUri = forest.getUriOfNode(fieldRefs[0]);
                if (refUri) {
                    return {
                        node: fieldRefs[0],
                        nodeType: "FieldType",
                        uri: refUri,
                    };
                }
            }
        }
    }
}
exports.TreeUtils = TreeUtils;
//# sourceMappingURL=treeUtils.js.map