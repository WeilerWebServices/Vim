"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findType = exports.InferenceScope = exports.typeArgumentCountError = exports.badRecursionError = exports.nthVarName = exports.getVarNames = exports.getTypeclassName = exports.uncurryFunction = exports.curryFunction = exports.TInProgressBinding = exports.TUnit = exports.TList = exports.TUnknown = exports.TMutableRecord = exports.TRecord = exports.TTuple = exports.TFunction = exports.TVar = exports.TUnion = void 0;
const treeUtils_1 = require("../treeUtils");
const references_1 = require("../references");
const operatorPrecedence_1 = require("./operatorPrecedence");
const disjointSet_1 = require("./disjointSet");
const typeReplacement_1 = require("./typeReplacement");
const expressionTree_1 = require("./expressionTree");
const syntaxNodeMap_1 = require("./syntaxNodeMap");
const typeExpression_1 = require("./typeExpression");
const sequence_1 = require("../sequence");
const utils_1 = require("../utils");
const recordFieldReferenceTable_1 = require("./recordFieldReferenceTable");
const typeRenderer_1 = require("./typeRenderer");
const tsyringe_1 = require("tsyringe");
exports.TUnion = (module, name, params, alias) => {
    return { nodeType: "Union", module, name, params, alias };
};
exports.TVar = (name, rigid = false) => {
    return { nodeType: "Var", name, rigid };
};
exports.TFunction = (params, ret, alias) => {
    return { nodeType: "Function", params, return: ret, alias };
};
exports.TTuple = (types, alias) => {
    if (types.length === 0) {
        throw new Error("Cannot create a TTuple with no types, use TUnit");
    }
    return { nodeType: "Tuple", types, alias };
};
exports.TRecord = (fields, baseType, alias, fieldReferences = new recordFieldReferenceTable_1.RecordFieldReferenceTable()) => {
    return {
        nodeType: "Record",
        fields,
        baseType,
        alias,
        fieldReferences,
    };
};
exports.TMutableRecord = (fields, baseType, fieldReferences = new recordFieldReferenceTable_1.RecordFieldReferenceTable()) => {
    return {
        nodeType: "MutableRecord",
        fields,
        baseType,
        fieldReferences,
    };
};
function mutableRecordAsRecord(mutableRecord) {
    return {
        nodeType: "Record",
        fields: mutableRecord.fields,
        baseType: mutableRecord.baseType,
        fieldReferences: mutableRecord.fieldReferences,
    };
}
exports.TUnknown = {
    nodeType: "Unknown",
};
const TInt = () => exports.TUnion("Basics", "Int", []);
const TFloat = () => exports.TUnion("Basics", "Float", []);
const TBool = () => exports.TUnion("Basics", "Bool", []);
const TString = () => exports.TUnion("String", "String", []);
const TChar = () => exports.TUnion("Char", "Char", []);
const TShader = () => exports.TUnion("WebGL", "Shader", [exports.TUnknown, exports.TUnknown, exports.TUnknown]);
exports.TList = (elementType) => exports.TUnion("List", "List", [elementType]);
const TNumber = () => exports.TVar("number");
exports.TUnit = {
    nodeType: "Unit",
};
exports.TInProgressBinding = {
    nodeType: "InProgressBinding",
};
const typeIsList = (t) => t.module === "List" && t.name === "List";
const typeIsInt = (t) => t.module === TInt().module && t.name === TInt().name;
const typeIsFloat = (t) => t.module === TFloat().module && t.name === TFloat().name;
const typeIsBool = (t) => t.module === TBool().module && t.name === TBool().name;
const typeIsString = (t) => t.module === TString().module && t.name === TString().name;
const typeIsChar = (t) => t.module === TChar().module && t.name === TChar().name;
function allTypeVars(type) {
    switch (type.nodeType) {
        case "Var":
            return [type];
        case "Union":
            return Array.prototype.flatMap !== undefined
                ? type.params.flatMap(allTypeVars)
                : treeUtils_1.flatMap(type.params, allTypeVars);
        case "Function":
            return allTypeVars(type.return).concat(Array.prototype.flatMap !== undefined
                ? type.params.flatMap(allTypeVars)
                : treeUtils_1.flatMap(type.params, allTypeVars));
        case "Tuple":
            return Array.prototype.flatMap !== undefined
                ? type.types.flatMap(allTypeVars)
                : treeUtils_1.flatMap(type.types, allTypeVars);
        case "Record":
        case "MutableRecord": {
            return [
                ...(Array.prototype.flatMap !== undefined
                    ? Object.values(type.fields).flatMap(allTypeVars)
                    : treeUtils_1.flatMap(Object.values(type.fields), allTypeVars)),
                ...(type.baseType ? allTypeVars(type.baseType) : []),
            ];
        }
        case "Unknown":
        case "Unit":
        case "InProgressBinding":
            return [];
    }
}
function anyTypeVar(type, predicate) {
    var _a;
    let result = false;
    switch (type.nodeType) {
        case "Var":
            result = predicate(type);
            break;
        case "Tuple":
            result = type.types.some((param) => anyTypeVar(param, predicate));
            break;
        case "Union":
            result = type.params.some((param) => anyTypeVar(param, predicate));
            break;
        case "Function":
            result =
                anyTypeVar(type.return, predicate) ||
                    type.params.some((param) => anyTypeVar(param, predicate));
            break;
        case "Record":
        case "MutableRecord":
            result =
                Object.values(type.fields).some((field) => anyTypeVar(field, predicate)) || (type.baseType ? anyTypeVar(type.baseType, predicate) : false);
            break;
        case "Unit":
        case "Unknown":
        case "InProgressBinding":
            result = false;
            break;
    }
    return (result ||
        ((_a = type.alias) === null || _a === void 0 ? void 0 : _a.parameters.some((param) => anyTypeVar(param, predicate))) ===
            true);
}
/**
 * Curry function helper
 * @param func The function type to curry
 * @param count The number params to partially apply
 */
function curryFunction(func, count) {
    if (count < func.params.length) {
        return exports.TFunction(func.params.slice(count), func.return);
    }
    else {
        return func.return;
    }
}
exports.curryFunction = curryFunction;
/**
 * Uncurry function helper
 * @param func The function type to uncurry
 */
function uncurryFunction(func) {
    if (func.return.nodeType === "Function") {
        return exports.TFunction([...func.params, ...func.return.params], func.return.return);
    }
    else {
        return func;
    }
}
exports.uncurryFunction = uncurryFunction;
function getParentPatternDeclaration(ref) {
    const parentPattern = expressionTree_1.mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findParentOfType("value_declaration", ref));
    if ((parentPattern === null || parentPattern === void 0 ? void 0 : parentPattern.nodeType) !== "ValueDeclaration") {
        throw new Error(`Failed to get parent pattern declaration`);
    }
    return parentPattern.pattern ? parentPattern : undefined;
}
function getTypeclassName(type) {
    switch (type.name) {
        case "number":
        case "appendable":
        case "comparable":
        case "compappend":
            return type.name;
    }
}
exports.getTypeclassName = getTypeclassName;
const VAR_LETTERS = "abcdefghijklmnopqrstuvwxyz";
function getVarNames(count) {
    const names = [];
    for (let i = 0; i < count; i++) {
        const letter = VAR_LETTERS[i % 26];
        if (i < 26) {
            names.push(letter);
        }
        else {
            names.push(`${letter}${i / 26}`);
        }
    }
    return names;
}
exports.getVarNames = getVarNames;
function nthVarName(n) {
    return getVarNames(n)[n - 1];
}
exports.nthVarName = nthVarName;
function typeMismatchError(node, found, expected, endNode, patternBinding = false, recordDiff) {
    const foundText = typeRenderer_1.TypeRenderer.typeToString(found);
    const expectedText = typeRenderer_1.TypeRenderer.typeToString(expected);
    const message = patternBinding
        ? `Invalid pattern error\nExpected: ${expectedText}\nFound: ${foundText}`
        : `Type mismatch error\nExpected: ${expectedText}\nFound: ${foundText}`;
    const recordDiffText = (diff) => {
        let s = "";
        if (diff.extra.size > 0) {
            s += `\nExtra fields: ${typeRenderer_1.TypeRenderer.typeToString(exports.TRecord(Object.fromEntries(diff.extra.entries())))}`;
        }
        if (diff.missing.size > 0) {
            s += `\nMissing fields: ${typeRenderer_1.TypeRenderer.typeToString(exports.TRecord(Object.fromEntries(diff.missing.entries())))}`;
        }
        if (diff.mismatched.size > 0) {
            s += `\nMismatched fields: `;
            diff.mismatched.forEach(([expected, found], field) => {
                s += `\n Field ${field} expected ${typeRenderer_1.TypeRenderer.typeToString(expected)}, found ${typeRenderer_1.TypeRenderer.typeToString(found)}`;
            });
        }
        return s;
    };
    return {
        node,
        endNode: endNode !== null && endNode !== void 0 ? endNode : node,
        message: message + (recordDiff ? recordDiffText(recordDiff) : ""),
    };
}
function parameterCountError(node, endNode, actual, expected, isType = false) {
    var _a, _b;
    const name = (_b = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    return {
        node,
        endNode,
        message: `The ${isType ? "type" : "function"} \`${name}\` expects ${expected} argument${expected !== 1 ? `s` : ``}, but got ${actual} instead`,
    };
}
function argumentCountError(node, endNode, actual, expected, isType = false) {
    var _a;
    if (expected === 0 && !isType) {
        const name = (_a = node.firstNamedChild) === null || _a === void 0 ? void 0 : _a.text;
        return {
            node,
            endNode,
            message: `${name ? `\`${name}\`` : "This value"} is not a function, but it was given ${actual} argument${actual !== 1 ? `s` : ``}`,
        };
    }
    else {
        return parameterCountError(node, endNode, actual, expected, isType);
    }
}
function redefinitionError(node) {
    return {
        node,
        endNode: node,
        message: `A value named \`${node.text}\` is already defined`,
    };
}
function badRecursionError(node) {
    return {
        node,
        endNode: node,
        message: `Infinite recursion`,
    };
}
exports.badRecursionError = badRecursionError;
function cyclicDefinitionError(node) {
    return {
        node,
        endNode: node,
        message: `Value cannot be defined in terms of itself`,
    };
}
function partialPatternError(node) {
    return {
        node,
        endNode: node,
        message: `Pattern does not cover all posiblities`,
    };
}
function typeArgumentCountError(node, actual, expected) {
    return {
        node,
        endNode: node,
        message: `The type expected ${expected} argument${expected !== 1 ? "s" : ""}, but got ${actual} instead`,
    };
}
exports.typeArgumentCountError = typeArgumentCountError;
function recordFieldError(node, field) {
    return {
        node,
        endNode: node,
        message: `The record does not have a \`${field}\` field`,
    };
}
function recordBaseIdError(node, type) {
    return {
        node,
        endNode: node,
        message: `Type must be a record, instead found: ${typeRenderer_1.TypeRenderer.typeToString(type)}`,
    };
}
function fieldAccessOnNonRecordError(node, type) {
    return {
        node,
        endNode: node,
        message: `Cannot access fields on non-record type: ${typeRenderer_1.TypeRenderer.typeToString(type)}`,
    };
}
function missingFunctionError(node) {
    return {
        node,
        endNode: node,
        message: `No function definition found for \`${node.text}\``,
    };
}
function missingValueError(node) {
    return {
        node,
        endNode: node,
        message: `No definition found for \`${node.text}\``,
    };
}
const RecordDiff = (extra, missing, mismatched) => {
    return {
        extra,
        missing,
        mismatched,
        isEmpty: extra.size === 0 && missing.size === 0 && mismatched.size === 0,
    };
};
class InferenceScope {
    constructor(uri, elmWorkspace, nonShadowableNames, activeScopes, recursionAllowed, parent) {
        var _a, _b;
        this.uri = uri;
        this.elmWorkspace = elmWorkspace;
        this.nonShadowableNames = nonShadowableNames;
        this.activeScopes = activeScopes;
        this.recursionAllowed = recursionAllowed;
        this.parent = parent;
        this.expressionTypes = new syntaxNodeMap_1.SyntaxNodeMap();
        this.diagnostics = [];
        this.bindings = new syntaxNodeMap_1.SyntaxNodeMap();
        this.annotationVars = [];
        this.childDeclarations = new Set();
        this.recordDiffs = new syntaxNodeMap_1.SyntaxNodeMap();
        this.replacements = (_a = parent === null || parent === void 0 ? void 0 : parent.replacements) !== null && _a !== void 0 ? _a : new disjointSet_1.DisjointSet();
        this.resolvedDeclarations = (_b = parent === null || parent === void 0 ? void 0 : parent.resolvedDeclarations) !== null && _b !== void 0 ? _b : new syntaxNodeMap_1.SyntaxNodeMap();
        this.ancestors = new sequence_1.Sequence(this, (scope) => scope.parent);
    }
    getBinding(e) {
        return this.ancestors
            .map((a) => a.bindings.get(e))
            .find(utils_1.Utils.notUndefined.bind(this));
    }
    static valueDeclarationInference(declaration, uri, elmWorkspace, activeScopes) {
        var _a;
        // TODO: Need a good way to get all visible values
        const shadowableNames = new Set();
        const setter = () => new InferenceScope(uri, elmWorkspace, shadowableNames, new Set(activeScopes.values()), 
        /* recursionAllowed */ false).inferDeclaration(declaration, true);
        if (!((_a = elmWorkspace.getForest().getByUri(uri)) === null || _a === void 0 ? void 0 : _a.writeable)) {
            return elmWorkspace
                .getTypeCache()
                .getOrSet("PACKAGE_VALUE_DECLARATION", declaration, setter);
        }
        else {
            return elmWorkspace
                .getTypeCache()
                .getOrSet("PROJECT_VALUE_DECLARATION", declaration, setter);
        }
    }
    inferDeclaration(declaration, replaceExpressionTypes) {
        this.activeScopes.add(declaration);
        // Bind the parameters so the body can reference them
        const binding = this.bindParameters(declaration);
        // If there is a pattern, it gets inferred in the parameter binding
        if (declaration.pattern) {
            return this.toTopLevelResult(exports.TUnknown);
        }
        let bodyType = exports.TUnknown;
        if (declaration.body) {
            bodyType = this.infer(declaration.body);
            // Make sure the returned type is what is annotated
            if (binding.bindingType === "Annotated") {
                const bindingType = binding.type;
                const expected = bindingType.nodeType === "Function"
                    ? curryFunction(bindingType, binding.count)
                    : bindingType;
                this.isAssignable(declaration.body, bodyType, expected);
            }
            else {
                this.checkTopLevelCaseBranches(declaration.body, bodyType);
            }
        }
        const type = binding.bindingType === "Annotated"
            ? binding.type
            : binding.bindingType === "Unannotated"
                ? binding.count === 0
                    ? bodyType
                    : uncurryFunction(exports.TFunction(binding.params, bodyType))
                : bodyType;
        return this.toTopLevelResult(type, replaceExpressionTypes);
    }
    checkTopLevelCaseBranches(expr, exprType) {
        if (expr.nodeType === "CaseOfExpr") {
            this.isBranchesAssignable(expr, exprType, exports.TUnknown);
        }
    }
    checkRecursion(declaration) {
        const isRecursive = !!Array.from(this.activeScopes.values()).find((d) => d.id === declaration.id);
        const functionDeclaration = expressionTree_1.mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("function_declaration_left", declaration));
        if (isRecursive &&
            !this.recursionAllowed &&
            ((functionDeclaration === null || functionDeclaration === void 0 ? void 0 : functionDeclaration.nodeType) !== "FunctionDeclarationLeft" ||
                !functionDeclaration.params[0])) {
            this.diagnostics.push(badRecursionError(declaration));
        }
        return isRecursive;
    }
    toTopLevelResult(type, replaceExpressionTypes = true) {
        if (replaceExpressionTypes) {
            this.expressionTypes.mapValues((val) => {
                const result = typeReplacement_1.TypeReplacement.replace(val, this.replacements.toMap());
                typeReplacement_1.TypeReplacement.freeze(result);
                return result;
            });
        }
        const outerVars = treeUtils_1.flatMap(this.ancestors.toArray().slice(1), (a) => a.annotationVars);
        const ret = typeReplacement_1.TypeReplacement.replace(type, this.replacements.toMap(), false, outerVars);
        if (replaceExpressionTypes) {
            typeReplacement_1.TypeReplacement.freeze(ret);
        }
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: ret,
            recordDiffs: this.recordDiffs,
        };
    }
    infer(e) {
        let type = exports.TUnknown;
        switch (e.nodeType) {
            case "AnonymousFunctionExpr":
                type = this.inferLambda(e);
                break;
            case "BinOpExpr":
                type = this.inferBinOpExpr(e);
                break;
            case "CaseOfExpr":
                type = this.inferCase(e);
                break;
            case "CharConstantExpr":
                type = TChar();
                break;
            case "FieldAccessExpr":
                type = this.inferFieldAccess(e);
                break;
            case "FieldAccessorFunctionExpr":
                type = this.inferFieldAccessorFunctionExpr(e);
                break;
            case "FunctionCallExpr":
                type = this.inferFunctionCallExpr(e);
                break;
            case "GlslCodeExpr":
                type = TShader();
                break;
            case "IfElseExpr":
                type = this.inferIfElse(e);
                break;
            case "LetInExpr":
                type = this.inferChild((inference) => inference.letInInference(e)).type;
                break;
            case "ListExpr":
                type = this.inferList(e);
                break;
            case "NegateExpr":
                type = this.inferNegateExpr(e);
                break;
            case "NumberConstant":
                type = e.isFloat ? TFloat() : TNumber();
                break;
            case "OperatorAsFunctionExpr":
                type = this.inferOperatorAsFunctionExpr(e);
                break;
            case "RecordExpr":
                type = this.inferRecord(e);
                break;
            case "StringConstant":
                type = TString();
                break;
            case "TupleExpr":
                type = exports.TTuple(e.exprList.map((expr) => this.infer(expr)));
                break;
            case "UnitExpr":
                type = exports.TUnit;
                break;
            case "ValueExpr":
                type = this.inferReferenceElement(e);
                break;
            default:
                throw new Error("Unexpected Expression type");
        }
        this.expressionTypes.set(e, type);
        return type;
    }
    lambdaInference(lamba) {
        const paramVars = this.uniqueVars(lamba.params.length);
        lamba.params.forEach((p, i) => this.bindPattern(p, paramVars[i], true));
        const bodyType = this.infer(lamba.expr);
        this.checkTopLevelCaseBranches(lamba.expr, bodyType);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: uncurryFunction(exports.TFunction(paramVars, bodyType)),
            recordDiffs: this.recordDiffs,
        };
    }
    letInInference(letInExpr) {
        const valueDeclarations = letInExpr.valueDeclarations;
        valueDeclarations.forEach((v) => this.childDeclarations.add(v));
        valueDeclarations.forEach((declaration) => {
            if (!this.resolvedDeclarations.has(declaration)) {
                this.inferChildDeclaration(declaration);
            }
        });
        const bodyType = this.infer(letInExpr.body);
        this.checkTopLevelCaseBranches(letInExpr.body, bodyType);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type: bodyType,
            recordDiffs: this.recordDiffs,
        };
    }
    caseBranchInference(pattern, caseType, branchExpr) {
        this.bindPattern(pattern, caseType, false);
        const type = this.infer(branchExpr);
        return {
            expressionTypes: this.expressionTypes,
            diagnostics: this.diagnostics,
            type,
            recordDiffs: this.recordDiffs,
        };
    }
    inferChild(callback, activeScopes = new Set(this.activeScopes.values()), recursionAllowed = this.recursionAllowed) {
        const result = callback(new InferenceScope(this.uri, this.elmWorkspace, new Set(this.nonShadowableNames.values()), activeScopes, recursionAllowed, this));
        this.diagnostics.push(...result.diagnostics);
        result.recordDiffs.forEach((val, key) => this.recordDiffs.set(key, val));
        result.expressionTypes.forEach((val, key) => this.expressionTypes.set(key, val));
        return result;
    }
    inferChildDeclaration(declaration, activeScopes = new Set(this.activeScopes.values())) {
        var _a, _b;
        const result = this.inferChild((inference) => inference.inferDeclaration(declaration, false), activeScopes);
        this.resolvedDeclarations.set(declaration, result.type);
        this.expressionTypes.set(declaration, result.type);
        const funcName = (_a = treeUtils_1.TreeUtils.getFunctionNameNodeFromDefinition(declaration)) === null || _a === void 0 ? void 0 : _a.text;
        if (funcName) {
            this.nonShadowableNames.add(funcName);
        }
        else {
            const pattern = declaration.pattern;
            if (pattern) {
                const patterns = (_b = pattern
                    .descendantsOfType("lower_pattern")) === null || _b === void 0 ? void 0 : _b.map(expressionTree_1.mapSyntaxNodeToExpression).filter(utils_1.Utils.notUndefined.bind(this));
                patterns === null || patterns === void 0 ? void 0 : patterns.forEach((pat) => {
                    const patType = result.expressionTypes.get(pat);
                    if (patType) {
                        this.setBinding(pat, patType);
                    }
                    this.nonShadowableNames.add(pat.text);
                });
            }
        }
        return result;
    }
    inferList(expr) {
        var _a;
        const exprTypes = expr.exprList.map((e) => this.infer(e));
        for (let i = 1; i < expr.exprList.length; i++) {
            if (this.isAssignable(expr.exprList[i], exprTypes[i], exprTypes[0])) {
                this.expressionTypes.set(expr.exprList[i], exprTypes[0]);
            }
            else {
                break;
            }
        }
        return exports.TList((_a = exprTypes[0]) !== null && _a !== void 0 ? _a : exports.TVar("a"));
    }
    inferIfElse(ifElseExpr) {
        const exprList = ifElseExpr.exprList;
        // Check for incomplete program
        if (exprList.length < 3 || exprList.length % 2 == 0) {
            return exports.TUnknown;
        }
        const exprTypes = exprList.map((e) => this.infer(e));
        // Check all conditions are type Bool
        for (let i = 0; i < exprList.length - 1; i += 2) {
            this.isAssignable(exprList[i], exprTypes[i], TBool());
        }
        // Check that all branches match the first one
        for (let i = 0; i < exprList.length; i++) {
            if (i != exprList.length - 1 && (i < 3 || i % 2 == 0)) {
                continue;
            }
            if (!this.isAssignable(exprList[i], exprTypes[i], exprTypes[1])) {
                break;
            }
        }
        return exprTypes[1];
    }
    inferReferenceElement(e) {
        var _a, _b, _c;
        const definition = (_b = expressionTree_1.findDefinition((_a = e.firstNamedChild) === null || _a === void 0 ? void 0 : _a.lastNamedChild, this.uri, this.elmWorkspace)) !== null && _b !== void 0 ? _b : expressionTree_1.findDefinition(e.firstNamedChild, this.uri, this.elmWorkspace);
        if (!definition) {
            this.diagnostics.push(missingValueError(e));
            return exports.TVar("a");
        }
        const binding = this.getBinding(definition.expr);
        if (binding) {
            if (binding.nodeType === "InProgressBinding") {
                this.diagnostics.push(cyclicDefinitionError(e));
                return exports.TUnknown;
            }
            else {
                return binding;
            }
        }
        switch (definition.expr.nodeType) {
            case "FunctionDeclarationLeft": {
                const valueDeclaration = expressionTree_1.mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findParentOfType("value_declaration", definition.expr));
                if ((valueDeclaration === null || valueDeclaration === void 0 ? void 0 : valueDeclaration.nodeType) !== "ValueDeclaration") {
                    throw new Error("Could not find parent value declaration");
                }
                return this.inferReferencedValueDeclaration(valueDeclaration, definition === null || definition === void 0 ? void 0 : definition.uri);
            }
            case "LowerPattern": {
                const parentPattern = getParentPatternDeclaration(definition.expr);
                if (parentPattern) {
                    this.inferReferencedValueDeclaration(parentPattern, definition.uri);
                    const binding = this.getBinding(definition.expr);
                    if (binding) {
                        return binding;
                    }
                    else {
                        throw new Error("Failed to destructure pattern");
                    }
                }
                throw new Error("Failed to bind pattern");
            }
            case "UnionVariant": {
                return typeExpression_1.TypeExpression.unionVariantInference(definition.expr, this.uri, this.elmWorkspace).type;
            }
            case "TypeAliasDeclaration": {
                const ty = typeExpression_1.TypeExpression.typeAliasDeclarationInference(definition.expr, this.uri, this.elmWorkspace).type;
                if (ty.nodeType === "Record" && Object.keys(ty.fields).length > 0) {
                    return exports.TFunction(Object.values(ty.fields), ty);
                }
                else {
                    return ty;
                }
            }
            case "FieldType": {
                const typeAlias = expressionTree_1.mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findParentOfType("type_alias_declaration", definition.expr));
                if (typeAlias && typeAlias.nodeType === "TypeAliasDeclaration") {
                    const fields = (_c = typeExpression_1.TypeExpression.typeAliasDeclarationInference(typeAlias, this.uri, this.elmWorkspace).type) === null || _c === void 0 ? void 0 : _c.fields;
                    if (fields) {
                        return fields[definition.expr.text];
                    }
                }
                return exports.TUnknown;
            }
            case "PortAnnotation": {
                return typeExpression_1.TypeExpression.portAnnotationInference(definition.expr, this.uri, this.elmWorkspace).type;
            }
            default:
                throw new Error("Unexpected reference type");
        }
    }
    inferReferencedValueDeclaration(declaration, referenceUri) {
        var _a;
        if (!declaration) {
            return exports.TUnknown;
        }
        const recursive = this.checkRecursion(declaration);
        const existing = this.resolvedDeclarations.get(declaration);
        if (existing) {
            return typeReplacement_1.TypeReplacement.freshenVars(existing);
        }
        let type;
        // Get the type annotation if there is one
        if (declaration.typeAnnotation) {
            type = (_a = typeExpression_1.TypeExpression.typeAnnotationInference(declaration.typeAnnotation, referenceUri, this.elmWorkspace, false)) === null || _a === void 0 ? void 0 : _a.type;
        }
        if (!type) {
            // Don't try to infer unannotated recursive functions
            if (recursive) {
                return exports.TUnknown;
            }
            const parentScope = this.ancestors.find((scope) => !!Array.from(scope.childDeclarations.values()).find((child) => child.id === declaration.id));
            type = !parentScope
                ? InferenceScope.valueDeclarationInference(declaration, referenceUri, this.elmWorkspace, this.activeScopes).type
                : parentScope.inferChildDeclaration(declaration, this.activeScopes)
                    .type;
        }
        this.resolvedDeclarations.set(declaration, type);
        return type;
    }
    inferFunctionCallExpr(e) {
        const targetType = this.infer(e.target);
        const argTypes = e.args.map((arg) => this.infer(arg));
        const argCountError = (expr, endExpr, actual, expected) => {
            this.diagnostics.push(argumentCountError(expr, endExpr, actual, expected));
            return exports.TUnknown;
        };
        if (targetType.nodeType === "Var") {
            const type = exports.TFunction(argTypes, exports.TVar("a"));
            if (this.isAssignable(e.target, targetType, type)) {
                return type.return;
            }
            else {
                return exports.TUnknown;
            }
        }
        if (targetType.nodeType === "Unknown") {
            const type = exports.TFunction(argTypes, exports.TVar("a"));
            if (this.isAssignable(e.target, targetType, type)) {
                this.expressionTypes.set(e.target, type);
                return type.return;
            }
            else {
                return exports.TUnknown;
            }
        }
        if (targetType.nodeType !== "Function") {
            return argCountError(e, e, e.args.length, 0);
        }
        let allAssignable = true;
        // Make sure each arg is assignable to the inferred type
        for (let i = 0; i < Math.min(e.args.length, targetType.params.length); i++) {
            allAssignable =
                this.isAssignable(e.args[i], argTypes[i], targetType.params[i]) &&
                    allAssignable;
        }
        if (allAssignable && e.args.length > targetType.params.length) {
            let appliedType = typeReplacement_1.TypeReplacement.replace(targetType.return, this.replacements.toMap());
            if (appliedType.nodeType !== "Function") {
                return argCountError(e, e, e.args.length, targetType.params.length);
            }
            for (let i = targetType.params.length; i < e.args.length - 1; i++) {
                if (appliedType.nodeType !== "Function") {
                    return argCountError(e.target, e.args[i], 1, 0);
                }
                if (!this.isAssignable(e.args[i], argTypes[i], appliedType.params[0])) {
                    return exports.TUnknown;
                }
                appliedType = typeReplacement_1.TypeReplacement.replace(curryFunction(appliedType, 1), this.replacements.toMap());
            }
            this.expressionTypes.set(e, appliedType);
            return appliedType;
        }
        const resultType = allAssignable
            ? typeReplacement_1.TypeReplacement.replace(curryFunction(targetType, e.args.length), this.replacements.toMap(), true)
            : exports.TUnknown;
        this.expressionTypes.set(e, resultType);
        return resultType;
    }
    inferBinOpExpr(e) {
        const operatorPrecedences = new syntaxNodeMap_1.SyntaxNodeMap();
        const operatorTypes = new syntaxNodeMap_1.SyntaxNodeMap();
        let lastPrecedence;
        for (const part of e.parts) {
            if (part.nodeType === "Operator") {
                const [type, precedence] = this.inferOperatorAndPrecedence(part);
                if (type.nodeType !== "Function" || type.params.length < 2) {
                    return exports.TUnknown;
                }
                if (precedence.associativity === "NON" &&
                    (lastPrecedence === null || lastPrecedence === void 0 ? void 0 : lastPrecedence.associativity) === "NON") {
                    this.diagnostics.push({
                        node: e,
                        endNode: e,
                        message: "NonAssociativeOperatorError",
                    });
                    return exports.TUnknown;
                }
                operatorPrecedences.set(part, precedence);
                operatorTypes.set(part, type);
                lastPrecedence = precedence;
            }
        }
        const validateTree = (tree) => {
            switch (tree.type) {
                case "Operand": {
                    const operandTree = tree;
                    const type = this.inferOperand(operandTree.operand);
                    return { start: operandTree.operand, end: operandTree.operand, type };
                }
                case "Binary": {
                    const binaryTree = tree;
                    const left = validateTree(binaryTree.left);
                    const right = validateTree(binaryTree.right);
                    const func = operatorTypes.get(binaryTree.operator);
                    if (!func) {
                        throw new Error("Missing function type for operator");
                    }
                    const leftAssignable = this.isAssignable(left.start, left.type, func.params[0], left.end);
                    const rightAssignable = this.isAssignable(right.start, right.type, func.params[1], right.end);
                    const type = leftAssignable && rightAssignable
                        ? typeReplacement_1.TypeReplacement.replace(curryFunction(func, 2), this.replacements.toMap(), true)
                        : exports.TUnknown;
                    return { start: left.start, end: right.end, type };
                }
            }
        };
        const result = validateTree(operatorPrecedence_1.BinaryExprTree.parse(e.parts, operatorPrecedences));
        this.expressionTypes.set(e, result.type);
        return result.type;
    }
    inferOperand(e) {
        if (e.nodeType === "FunctionCallExpr") {
            return this.inferFunctionCallExpr(e);
        }
        return this.infer(e);
    }
    inferOperatorAndPrecedence(e) {
        // Find operator reference
        const definition = expressionTree_1.findDefinition(e, this.uri, this.elmWorkspace);
        const opDeclaration = expressionTree_1.mapSyntaxNodeToExpression(definition === null || definition === void 0 ? void 0 : definition.expr.parent);
        const infixDeclarationExpr = expressionTree_1.mapSyntaxNodeToExpression(opDeclaration ? references_1.References.findOperator(opDeclaration) : undefined);
        if ((opDeclaration === null || opDeclaration === void 0 ? void 0 : opDeclaration.nodeType) !== "ValueDeclaration" ||
            (infixDeclarationExpr === null || infixDeclarationExpr === void 0 ? void 0 : infixDeclarationExpr.nodeType) !== "InfixDeclaration" ||
            !definition) {
            return [exports.TUnknown, { precedence: 0, associativity: "NON" }];
        }
        const type = this.inferReferencedValueDeclaration(opDeclaration, definition.uri);
        this.expressionTypes.set(e, type);
        return [
            type,
            {
                precedence: infixDeclarationExpr.precedence,
                associativity: infixDeclarationExpr.associativity,
            },
        ];
    }
    inferFieldAccessorFunctionExpr(accessor) {
        var _a, _b;
        const field = (_b = (_a = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", accessor)) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
        const typeVar = exports.TVar("b");
        return exports.TFunction([exports.TMutableRecord({ [field]: typeVar }, exports.TVar("a"))], typeVar);
    }
    inferNegateExpr(negateExpr) {
        const exprType = this.infer(negateExpr.expression);
        if (this.isAssignable(negateExpr.expression, exprType, TNumber())) {
            return exprType;
        }
        else {
            return exports.TUnknown;
        }
    }
    inferOperatorAsFunctionExpr(operatorFunction) {
        // Find operator reference
        const definition = expressionTree_1.findDefinition(operatorFunction.operator, this.uri, this.elmWorkspace);
        const opDeclaration = expressionTree_1.mapSyntaxNodeToExpression(definition === null || definition === void 0 ? void 0 : definition.expr.parent);
        if ((opDeclaration === null || opDeclaration === void 0 ? void 0 : opDeclaration.nodeType) === "ValueDeclaration" && (definition === null || definition === void 0 ? void 0 : definition.uri)) {
            return this.inferReferencedValueDeclaration(opDeclaration, definition.uri);
        }
        else {
            return exports.TUnknown;
        }
    }
    inferFieldAccess(expr) {
        var _a;
        const targetType = this.inferFieldAccessTarget(expr.target);
        const targetTy = this.replacements.get(targetType);
        const fieldIdentifier = treeUtils_1.TreeUtils.findFirstNamedChildOfType("lower_case_identifier", expr);
        if (!fieldIdentifier || fieldIdentifier.text === "") {
            return exports.TUnknown;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) === "Var") {
            if (targetTy.rigid) {
                this.diagnostics.push(recordBaseIdError(expr.target, targetTy));
                return exports.TUnknown;
            }
            const type = exports.TVar("b");
            this.trackReplacement(targetType, exports.TMutableRecord({ [fieldIdentifier.text]: type }, exports.TVar("a")));
            this.expressionTypes.set(expr, type);
            return type;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) === "MutableRecord") {
            let type = targetTy.fields[fieldIdentifier.text];
            if (!type) {
                targetTy.fields[fieldIdentifier.text] = exports.TVar(nthVarName(Object.keys(targetTy.fields).length));
                type = targetTy.fields[fieldIdentifier.text];
            }
            this.expressionTypes.set(expr, type);
            return type;
        }
        if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) !== "Record") {
            if ((targetTy === null || targetTy === void 0 ? void 0 : targetTy.nodeType) !== "Unknown" && targetTy) {
                this.diagnostics.push(fieldAccessOnNonRecordError(expr.target, targetTy));
            }
            return exports.TUnknown;
        }
        if (!Object.keys(targetTy.fields).includes(fieldIdentifier.text)) {
            if (!targetTy.baseType) {
                this.diagnostics.push(recordFieldError(fieldIdentifier, fieldIdentifier.text));
            }
        }
        const type = (_a = targetTy.fields[fieldIdentifier.text]) !== null && _a !== void 0 ? _a : exports.TUnknown;
        this.expressionTypes.set(expr, type);
        return type;
    }
    inferFieldAccessTarget(target) {
        var _a;
        let type = exports.TUnknown;
        switch (target.nodeType) {
            case "ValueExpr":
                type = this.inferReferenceElement(target);
                break;
            case "RecordExpr":
                type = this.inferRecord(target);
                break;
            case "FieldAccessExpr":
                type = this.inferFieldAccess(target);
                break;
            default:
                if (((_a = target.parent) === null || _a === void 0 ? void 0 : _a.type) === "parenthesized_expr") {
                    type = this.infer(target);
                }
                else {
                    throw new Error("Unexpected field access target expression");
                }
        }
        this.expressionTypes.set(target, type);
        return type;
    }
    inferLambda(lambaExpr) {
        return this.inferChild((inference) => inference.lambdaInference(lambaExpr), undefined, true).type;
    }
    inferCase(caseOfExpr) {
        const caseOfExprType = this.infer(caseOfExpr.expr);
        let type;
        caseOfExpr.branches.forEach((branch) => {
            const result = this.inferChild((inference) => inference.caseBranchInference(branch.pattern, caseOfExprType, branch.expr));
            if (!type) {
                type = result.type;
            }
        });
        return type !== null && type !== void 0 ? type : exports.TUnknown;
    }
    inferRecord(record) {
        const fields = new Map(record.fields.map((field) => [field.name, this.infer(field.expression)]));
        const mappedFields = {};
        fields.forEach((type, field) => (mappedFields[field.text] = type));
        const recordIdentifier = record.baseRecord;
        if (!recordIdentifier) {
            return exports.TRecord(mappedFields);
        }
        const baseType = this.inferReferenceElement(recordIdentifier);
        if (baseType.nodeType === "Unknown") {
            return exports.TUnknown;
        }
        if (baseType.nodeType === "Var") {
            const extRecord = exports.TRecord(mappedFields, exports.TVar(baseType.name));
            if (this.isAssignable(recordIdentifier, baseType, extRecord)) {
                return extRecord;
            }
            else {
                return exports.TUnknown;
            }
        }
        let baseFields = {};
        if (baseType.nodeType === "Record" ||
            baseType.nodeType === "MutableRecord") {
            baseFields = baseType.fields;
        }
        else {
            this.diagnostics.push({
                node: recordIdentifier,
                endNode: recordIdentifier,
                message: "RecordBaseIdError",
            });
            return exports.TUnknown;
        }
        fields.forEach((type, field) => {
            const expected = baseFields[field.text];
            if (!expected) {
                if (baseType.nodeType === "Record") {
                    if (!baseType.baseType) {
                        this.diagnostics.push(recordFieldError(field, field.text));
                        this.recordDiffs.set(record, this.calculateRecordDiff(exports.TRecord(mappedFields), baseType));
                    }
                }
                else if (baseType.nodeType === "MutableRecord") {
                    baseType.fields[field.text] = type;
                }
            }
            else {
                this.isAssignable(field, type, expected);
            }
        });
        return baseType;
    }
    setBinding(expr, type) {
        const exprName = expr.text;
        if (this.nonShadowableNames.has(exprName)) {
            this.diagnostics.push(redefinitionError(expr));
        }
        this.nonShadowableNames.add(exprName);
        this.bindings.set(expr, type);
        this.expressionTypes.set(expr, type);
    }
    bindParameters(valueDeclaration) {
        const functionDeclarationLeft = expressionTree_1.mapSyntaxNodeToExpression(treeUtils_1.TreeUtils.findFirstNamedChildOfType("function_declaration_left", valueDeclaration));
        if (functionDeclarationLeft) {
            return this.bindFunctionDeclarationParameters(valueDeclaration, functionDeclarationLeft);
        }
        if (valueDeclaration.pattern) {
            this.bindPatternDeclarationParameters(valueDeclaration, valueDeclaration.pattern);
            return { bindingType: "Other", count: 0 };
        }
        return { bindingType: "Other", count: 0 };
    }
    bindFunctionDeclarationParameters(valueDeclaration, functionDeclaration) {
        var _a;
        const typeRefType = valueDeclaration.typeAnnotation
            ? (_a = typeExpression_1.TypeExpression.typeAnnotationInference(valueDeclaration.typeAnnotation, this.uri, this.elmWorkspace, true)) === null || _a === void 0 ? void 0 : _a.type : undefined;
        const patterns = functionDeclaration.params;
        if (!typeRefType) {
            const params = this.uniqueVars(patterns.length);
            patterns.forEach((pat, i) => this.bindPattern(pat, params[i], true));
            return {
                bindingType: "Unannotated",
                params,
                count: params.length,
            };
        }
        const maxParams = typeRefType.nodeType === "Function" ? typeRefType.params.length : 0;
        if (patterns.length > maxParams) {
            this.diagnostics.push(parameterCountError(patterns[0], patterns[patterns.length - 1], patterns.length, maxParams));
            patterns.forEach((pat) => this.bindPattern(pat, exports.TUnknown, true));
            return { count: maxParams };
        }
        if (typeRefType.nodeType === "Function") {
            patterns.forEach((pat, i) => this.bindPattern(pat, typeRefType.params[i], true));
        }
        this.annotationVars = allTypeVars(typeRefType);
        return {
            bindingType: "Annotated",
            type: typeRefType,
            count: patterns.length,
        };
    }
    bindPatternDeclarationParameters(valueDeclaration, pattern) {
        // Bind all patters to a InProgressBinding type
        // so we can use them before we know the type
        const declaredNames = pattern.descendantsOfType("lower_pattern");
        declaredNames.forEach((name) => this.bindings.set(name, exports.TInProgressBinding));
        const bodyType = valueDeclaration.body
            ? this.infer(valueDeclaration.body)
            : exports.TUnknown;
        this.bindPattern(pattern, bodyType, false);
        // Make sure there are none still in progress, or else there was a mistake
        declaredNames.forEach((name) => {
            var _a;
            if (((_a = this.getBinding(name)) === null || _a === void 0 ? void 0 : _a.nodeType) === "InProgressBinding") {
                throw new Error(`Failed to bind parameter ${name.text}`);
            }
        });
    }
    bindPattern(pattern, type, isParameter) {
        var _a;
        const ty = (_a = this.replacements.get(type)) !== null && _a !== void 0 ? _a : type;
        switch (pattern.nodeType) {
            case "AnythingPattern":
                break;
            case "ConsPattern":
                if (isParameter) {
                    this.diagnostics.push(partialPatternError(pattern));
                    this.bindConsPattern(pattern, exports.TUnknown);
                }
                else {
                    this.bindConsPattern(pattern, ty);
                }
                break;
            case "LowerPattern":
                this.setBinding(pattern, ty);
                break;
            case "ListPattern":
                if (isParameter) {
                    this.bindListPattern(pattern, exports.TUnknown);
                }
                else {
                    this.bindListPattern(pattern, ty);
                }
                break;
            case "Pattern":
                {
                    const child = expressionTree_1.mapSyntaxNodeToExpression(pattern.namedChildren.find((c) => c.type.endsWith("pattern") ||
                        c.type.includes("constant") ||
                        c.type === "unit_expr"));
                    if (!child) {
                        throw new Error("Missing pattern child");
                    }
                    this.bindPattern(child, ty, isParameter);
                    if (pattern.patternAs) {
                        this.bindPattern(pattern.patternAs, ty, isParameter);
                    }
                }
                break;
            case "RecordPattern":
                this.bindRecordPattern(pattern, ty, isParameter);
                break;
            case "TuplePattern":
                this.bindTuplePattern(pattern, ty, isParameter);
                break;
            case "UnionPattern":
                this.bindUnionPattern(pattern, ty, isParameter);
                break;
            case "UnitExpr":
                this.isAssignable(pattern, ty, exports.TUnit, undefined, true);
                break;
            case "StringConstant":
            case "NumberConstant":
            case "CharConstantExpr":
                if (isParameter) {
                    this.diagnostics.push(partialPatternError(pattern));
                }
                break;
            default:
                throw new Error("Unexpected pattern type: " + pattern.nodeType);
        }
    }
    bindTuplePattern(tuplePattern, type, isParameter) {
        const patterns = tuplePattern.patterns;
        const ty = this.bindIfVar(tuplePattern, type, exports.TTuple(this.uniqueVars(patterns.length)));
        if (ty.nodeType !== "Tuple" || ty.types.length !== patterns.length) {
            patterns.forEach((pat) => this.bindPattern(pat, exports.TUnknown, isParameter));
            if (ty.nodeType !== "Unknown") {
                const actualType = exports.TTuple(this.uniqueVars(patterns.length));
                this.diagnostics.push(typeMismatchError(tuplePattern, actualType, ty, tuplePattern, true));
            }
            return;
        }
        patterns.forEach((pat, i) => {
            this.bindPattern(pat, ty.types[i], isParameter);
        });
    }
    bindUnionPattern(unionPattern, type, isParameter) {
        const variant = expressionTree_1.findDefinition(unionPattern.constructor.lastNamedChild, this.uri, this.elmWorkspace);
        if ((variant === null || variant === void 0 ? void 0 : variant.expr.nodeType) !== "UnionVariant") {
            throw new Error("Could not find UnionVariant for " + unionPattern.text);
        }
        const variantType = typeExpression_1.TypeExpression.unionVariantInference(variant.expr, variant.uri, this.elmWorkspace).type;
        if (!variantType || variantType.nodeType === "Unknown") {
            unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            return;
        }
        const issueError = (actual, expected) => {
            this.diagnostics.push(argumentCountError(unionPattern, unionPattern, actual, expected, true));
            unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
        };
        if (variantType.nodeType === "Function") {
            const ty = this.bindIfVar(unionPattern, type, variantType.return);
            if (this.isAssignable(unionPattern, ty, variantType.return)) {
                if (unionPattern.argPatterns.length !== variantType.params.length) {
                    issueError(unionPattern.argPatterns.length, variantType.params.length);
                }
                else {
                    unionPattern.argPatterns.forEach((p, i) => {
                        // The other type is a nullary constructor argument pattern, which doesn't bind anything
                        if (p.type.includes("pattern") &&
                            p.nodeType !== "NullaryConstructorArgumentPattern") {
                            this.bindPattern(p, variantType.params[i], isParameter);
                        }
                    });
                }
            }
            else {
                unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            }
        }
        else {
            const ty = this.bindIfVar(unionPattern, type, variantType);
            if (this.isAssignable(unionPattern, ty, variantType) &&
                unionPattern.argPatterns.length > 0) {
                issueError(unionPattern.argPatterns.length, 0);
            }
            else {
                unionPattern.namedParams.forEach((p) => this.setBinding(p, exports.TUnknown));
            }
        }
    }
    bindConsPattern(consPattern, type) {
        this.bindListPatternParts(consPattern, consPattern.parts, type, true);
    }
    bindListPattern(listPattern, type) {
        this.bindListPatternParts(listPattern, listPattern.parts, type, false);
    }
    bindListPatternParts(listPattern, parts, type, isCons) {
        const ty = this.bindIfVar(listPattern, type, exports.TList(exports.TVar("a")));
        if (ty.nodeType !== "Union" || !typeIsList(ty)) {
            if (ty.nodeType !== "Unknown") {
                this.diagnostics.push(typeMismatchError(listPattern, exports.TList(exports.TVar("a")), ty, listPattern, true));
            }
            parts.forEach((p) => this.bindPattern(p, exports.TUnknown, false));
            return;
        }
        const innerType = ty.params[0];
        parts.slice(0, parts.length - 1).forEach((part) => {
            const t = part.nodeType === "ListPattern" ? ty : innerType;
            this.bindPattern(part, t, false);
        });
        if (parts.length > 0) {
            this.bindPattern(parts[parts.length - 1], isCons ? ty : innerType, false);
        }
    }
    bindRecordPattern(pattern, type, isParameter) {
        var _a, _b;
        const fields = pattern.patternList;
        const ty = this.bindIfVar(pattern, type, exports.TMutableRecord({}, exports.TVar("a")));
        const vars = this.uniqueVars(fields.length);
        if (ty.nodeType === "MutableRecord") {
            fields.forEach((field, i) => {
                const existing = ty.fields[field.text];
                if (!existing) {
                    ty.fields[field.text] = vars[i];
                }
            });
        }
        else if (ty.nodeType !== "Record" ||
            fields.some((field) => !Object.keys(ty.fields).includes(field.text))) {
            if (ty.nodeType !== "Unknown") {
                const actualTyParams = Object.fromEntries(fields.map((field, i) => [field.text, vars[i]]));
                const actualTy = exports.TRecord(actualTyParams);
                const recordDiff = ty.nodeType === "Record"
                    ? Object.assign(Object.assign({}, this.calculateRecordDiff(actualTy, ty)), { missing: new Map() }) : undefined;
                this.diagnostics.push(typeMismatchError(pattern, actualTy, ty, undefined, true, recordDiff));
                if (recordDiff) {
                    this.recordDiffs.set(pattern, recordDiff);
                }
            }
            fields.forEach((field) => {
                this.bindPattern(field, exports.TUnknown, isParameter);
            });
            return;
        }
        const tyFields = (_b = (_a = ty) === null || _a === void 0 ? void 0 : _a.fields) !== null && _b !== void 0 ? _b : ty.fields;
        fields.forEach((field) => {
            this.bindPattern(field, tyFields[field.text], isParameter);
        });
        this.expressionTypes.set(pattern, type);
    }
    isAssignable(expr, type1, type2, endExpr, patternBinding = false) {
        if (!type1 || !type2) {
            throw new Error("Undefined type error");
        }
        let assignable;
        if (expr.nodeType === "CaseOfExpr") {
            return this.isBranchesAssignable(expr, type1, type2);
        }
        try {
            assignable = this.assignable(type1, type2);
        }
        catch (e) {
            this.diagnostics.push({
                node: expr,
                endNode: endExpr !== null && endExpr !== void 0 ? endExpr : expr,
                message: e.message,
            });
            return false;
        }
        if (!assignable) {
            const t1 = typeReplacement_1.TypeReplacement.replace(type1, this.replacements.toMap());
            const t2 = typeReplacement_1.TypeReplacement.replace(type2, this.replacements.toMap());
            const diff = t1.nodeType === "Record" && t2.nodeType === "Record"
                ? this.calculateRecordDiff(t1, t2)
                : undefined;
            const errorExpr = expr.nodeType === "LetInExpr" ? expr.body : expr;
            this.diagnostics.push(typeMismatchError(errorExpr, t1, t2, errorExpr, patternBinding));
            if (diff && expr.nodeType === "RecordExpr") {
                this.recordDiffs.set(expr, diff);
            }
        }
        return assignable;
    }
    isBranchesAssignable(expr, type1, type2) {
        // If type2 is not a concrete type, then every branch should match the first type
        const t2 = type2.nodeType !== "Unknown" && type2.nodeType !== "Var" ? type2 : type1;
        return expr.branches.every((branch) => {
            const t1 = this.expressionTypes.get(branch.expr);
            return t1 ? this.isAssignable(branch.expr, t1, t2) : false;
        });
    }
    assignable(type1, type2) {
        const ty1 = this.replacements.get(type1);
        const ty2 = this.replacements.get(type2);
        let result = ty1 === ty2 || (ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) === "Unknown" || (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Unknown";
        if (!result) {
            if ((ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) !== "Var" && (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Var") {
                result = this.nonVarAssignableToVar(ty1, ty2);
            }
            else {
                switch (ty1 === null || ty1 === void 0 ? void 0 : ty1.nodeType) {
                    case "Var":
                        if ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Var") {
                            result = this.varsAssignable(ty1, ty2);
                        }
                        else {
                            result = this.nonVarAssignableToVar(ty2, ty1);
                        }
                        break;
                    case "Union":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Union" &&
                                    ty1.name === ty2.name &&
                                    ty1.module === ty2.module &&
                                    this.allAssignable(ty1.params, ty2.params);
                        }
                        break;
                    case "Function":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Function" &&
                                    this.functionAssignable(ty1, ty2);
                        }
                        break;
                    case "Tuple":
                        {
                            result =
                                (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Tuple" &&
                                    ty1.types.length === ty2.types.length &&
                                    this.allAssignable(ty1.types, ty2.types);
                        }
                        break;
                    case "Record":
                        {
                            result =
                                ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Record" &&
                                    this.recordAssignable(ty1, ty2)) ||
                                    ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "MutableRecord" &&
                                        this.mutableRecordAssignable(ty2, ty1));
                        }
                        break;
                    case "MutableRecord":
                        {
                            result =
                                ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Record" &&
                                    this.mutableRecordAssignable(ty1, ty2)) ||
                                    ((ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "MutableRecord" &&
                                        this.mutableRecordAssignable(ty1, mutableRecordAsRecord(ty2)));
                        }
                        break;
                    case "Unit":
                        result = (ty2 === null || ty2 === void 0 ? void 0 : ty2.nodeType) === "Unit";
                        break;
                    case "Unknown":
                        result = true;
                        break;
                    case "InProgressBinding":
                        throw new Error(`Should never try to assign an in progress binding`);
                }
            }
        }
        if (ty1 && ty2 && result) {
            this.trackReplacement(ty1, ty2);
        }
        return result;
    }
    mutableRecordAssignable(type1, type2) {
        if (!this.recordAssignable(mutableRecordAsRecord(type1), type2)) {
            return false;
        }
        type1.fields = Object.assign(Object.assign({}, type1.fields), type2.fields);
        return true;
    }
    recordAssignable(type1, type2) {
        var _a, _b;
        const result = this.calculateRecordDiff(type1, type2).isEmpty;
        if (result) {
            if (!type1.baseType && ((_a = type2.baseType) === null || _a === void 0 ? void 0 : _a.nodeType) === "Var") {
                this.trackReplacement(type1, type2.baseType);
            }
            if (!type2.baseType && ((_b = type1.baseType) === null || _b === void 0 ? void 0 : _b.nodeType) === "Var") {
                this.trackReplacement(type1.baseType, type2);
            }
            type1.fieldReferences.addAll(type2.fieldReferences);
            type2.fieldReferences.addAll(type1.fieldReferences);
        }
        return result;
    }
    calculateRecordDiff(actual, expected) {
        const actualEntries = Object.entries(actual.fields);
        const actualKeys = Object.keys(actual.fields);
        const expectedEntries = Object.entries(expected.fields);
        const expectedKeys = Object.keys(expected.fields);
        return RecordDiff(expected.baseType
            ? new Map()
            : new Map(actualEntries.filter(([field]) => !expectedKeys.includes(field))), actual.baseType
            ? new Map()
            : new Map(expectedEntries.filter(([field]) => !actualKeys.includes(field))), new Map(actualEntries
            .map(([k, v]) => {
            if (expected.fields[k] && !this.assignable(v, expected.fields[k])) {
                return [k, [v, expected.fields[k]]];
            }
            return undefined;
        })
            .filter(utils_1.Utils.notUndefined.bind(this))));
    }
    allAssignable(type1, type2) {
        return (type1.length === type2.length &&
            type1.every((t, i) => this.assignable(t, type2[i])));
    }
    functionAssignable(type1, type2) {
        const allTypes1 = type1.params.concat(type1.return);
        const allTypes2 = type2.params.concat(type2.return);
        // If there is only one type, return it
        // If there are multiple, curry it into a new function
        function makeFunction(types) {
            if (types.length === 1) {
                return types[0];
            }
            else {
                return exports.TFunction(types.slice(0, types.length - 1), types[types.length - 1]);
            }
        }
        const paramsSize = Math.min(allTypes1.length, allTypes2.length) - 1;
        // Make sure the shared parameters are assignable
        const sharedAssignable = this.allAssignable(allTypes1.slice(0, paramsSize), allTypes2.slice(0, paramsSize));
        const tailAssignable = this.assignable(makeFunction(allTypes1.slice(paramsSize)), makeFunction(allTypes2.slice(paramsSize)));
        return sharedAssignable && tailAssignable;
    }
    /**
     * Check that two type vars can be unified
     */
    varsAssignable(type1, type2) {
        const typeClass1 = getTypeclassName(type1);
        const typeClass2 = getTypeclassName(type2);
        if (!type1.rigid && !typeClass1) {
            return true;
        }
        else if (!type1.rigid && typeClass1) {
            return (this.typeclassesCompatible(typeClass1, typeClass2, !type2.rigid) ||
                (!type2.rigid &&
                    this.typeclassesConstrainToCompappend(typeClass1, typeClass2)));
        }
        else if (type1.rigid && !typeClass1) {
            return !type2.rigid && !typeClass2;
        }
        else if (type1.rigid && typeClass1 && type2.rigid) {
            // If they are both rigid and we have a type class, they must be the same typeclass
            return typeClass1 === typeClass2;
        }
        else if (type1.rigid && typeClass1 && !type2.rigid) {
            return this.typeclassesCompatible(typeClass1, typeClass2, !type2.rigid);
        }
        else {
            throw new Error("Impossible");
        }
    }
    nonVarAssignableToVar(type, typeVar) {
        const allAssignableTo = (types, typeClass) => {
            return types.every((t) => this.assignable(t, exports.TVar(typeClass)));
        };
        if (typeVar.name.startsWith("number")) {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" && (typeIsFloat(type) || typeIsInt(type)));
        }
        else if (typeVar.name.startsWith("appendable")) {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" && (typeIsString(type) || typeIsList(type)));
        }
        else if (typeVar.name.startsWith("comparable")) {
            if ((type === null || type === void 0 ? void 0 : type.nodeType) === "Tuple") {
                return allAssignableTo(type.types, "comparable");
            }
            else if ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union") {
                return (typeIsFloat(type) ||
                    typeIsInt(type) ||
                    typeIsChar(type) ||
                    typeIsString(type) ||
                    (typeIsList(type) &&
                        (allAssignableTo(type.params, "comparable") ||
                            allAssignableTo(type.params, "number"))));
            }
            else {
                return false;
            }
        }
        else if (typeVar.name.startsWith("compappend")) {
            return ((type === null || type === void 0 ? void 0 : type.nodeType) === "Union" &&
                (typeIsString(type) ||
                    (typeIsList(type) &&
                        (allAssignableTo(type.params, "comparable") ||
                            allAssignableTo(type.params, "compappend")))));
        }
        return !typeVar.rigid;
    }
    typeclassesCompatible(name1, name2, unconstrainedAllowed = true) {
        if (!name2) {
            return unconstrainedAllowed;
        }
        if (name1 === name2) {
            return true;
        }
        if (name1 === "number" && name2 === "comparable") {
            return true;
        }
        if (name1 === "comparable" && name2 === "number") {
            return true;
        }
        if (name1 === "comparable" &&
            (name2 === "number" || name2 === "compappend")) {
            return true;
        }
        if (name1 === "compappend" &&
            (name2 === "comparable" || name2 === "appendable")) {
            return true;
        }
        return false;
    }
    typeclassesConstrainToCompappend(tc1, tc2) {
        if (tc1 === "comparable") {
            return tc2 === "appendable" || tc2 === "compappend";
        }
        if (tc1 === "appendable") {
            return tc2 === "comparable" || tc2 === "compappend";
        }
        return false;
    }
    trackReplacement(type1, type2) {
        var _a;
        if (type1 === type2) {
            return;
        }
        // Assign k to be of type v
        const assign = (typeVar, type) => {
            if (anyTypeVar(type, (tVar) => tVar === typeVar)) {
                throw Error("InfiniteTypeException");
            }
            this.replacements.set(typeVar, type);
        };
        // If we assign anything to a var, the type is constrained to that var
        if (type2.nodeType === "Var" &&
            (!this.replacements.contains(type2) ||
                (type1.nodeType !== "Var" &&
                    ((_a = this.replacements.get(type2)) === null || _a === void 0 ? void 0 : _a.nodeType) === "Var"))) {
            if (type1.nodeType === "Var") {
                const typeClass1 = getTypeclassName(type1);
                const typeClass2 = getTypeclassName(type2);
                if (!typeClass1 && typeClass2) {
                    // Assigning a => number, a should be constrained to number
                    assign(type1, type2);
                }
                else if (!type1.rigid &&
                    !type2.rigid &&
                    this.typeclassesConstrainToCompappend(typeClass1, typeClass2)) {
                    assign(type1, typeClass2 === "compappend" ? type2 : exports.TVar("compappend"));
                }
                else if (!type1.rigid &&
                    !type2.rigid &&
                    typeClass1 === "comparable" &&
                    typeClass2 === "number") {
                    // comparable is constrained to number
                    assign(type1, type2);
                }
                else if (!type1.rigid && type2.rigid) {
                    // Assigning a flex var to a rigid var makes it rigid
                    assign(type1, type2);
                }
                else {
                    assign(type2, type1);
                }
            }
            else {
                // Int => number contrains number to be an Int
                assign(type2, type1);
            }
        }
        // Assigning a var to a non var type constrains the type
        if (type1.nodeType === "Var" &&
            type2.nodeType !== "Var" &&
            !this.replacements.contains(type1)) {
            if (type2.nodeType === "Record" && type2.baseType) {
                assign(type1, exports.TMutableRecord(Object.assign({}, type2.fields), type2.baseType));
            }
            else {
                assign(type1, type2);
            }
        }
    }
    bindIfVar(e, type, defaultType) {
        if (type.nodeType === "Var") {
            this.isAssignable(e, type, defaultType, undefined, true);
            return defaultType;
        }
        else {
            return type;
        }
    }
    uniqueVars(count) {
        return getVarNames(count).map((val) => {
            return exports.TVar(val);
        });
    }
}
exports.InferenceScope = InferenceScope;
function findType(node, uri, workspace) {
    var _a, _b, _c, _d, _e;
    try {
        let declaration = node;
        while (declaration &&
            (declaration.type !== "value_declaration" ||
                ((_a = declaration.parent) === null || _a === void 0 ? void 0 : _a.type) !== "file")) {
            declaration = declaration.parent;
        }
        // We can't find the top level declaration
        if ((declaration === null || declaration === void 0 ? void 0 : declaration.type) !== "value_declaration" ||
            ((_b = declaration.parent) === null || _b === void 0 ? void 0 : _b.type) !== "file") {
            return exports.TUnknown;
        }
        const mappedDeclaration = expressionTree_1.mapSyntaxNodeToExpression(declaration);
        if (mappedDeclaration &&
            mappedDeclaration.nodeType === "ValueDeclaration") {
            const inferenceResult = InferenceScope.valueDeclarationInference(mappedDeclaration, uri, workspace, new Set());
            if ((node === null || node === void 0 ? void 0 : node.type) === "function_declaration_left") {
                const declaration = treeUtils_1.TreeUtils.findParentOfType("value_declaration", node);
                if (declaration) {
                    return ((_c = inferenceResult.expressionTypes.get(declaration)) !== null && _c !== void 0 ? _c : inferenceResult.type);
                }
                else {
                    return exports.TUnknown;
                }
            }
            else if (node.type === "value_declaration") {
                return ((_d = inferenceResult.expressionTypes.get(node)) !== null && _d !== void 0 ? _d : inferenceResult.type);
            }
            const findTypeOrParentType = (expr) => {
                var _a, _b, _c;
                const found = expr
                    ? inferenceResult.expressionTypes.get(expr)
                    : undefined;
                if (found) {
                    return found;
                }
                // Check if the parent is the same text and position
                if (expr &&
                    expr.text === ((_a = expr.parent) === null || _a === void 0 ? void 0 : _a.text) &&
                    expr.startIndex === ((_b = expr.parent) === null || _b === void 0 ? void 0 : _b.startIndex) &&
                    expr.endIndex === ((_c = expr.parent) === null || _c === void 0 ? void 0 : _c.endIndex)) {
                    return findTypeOrParentType(expr.parent);
                }
            };
            return (_e = findTypeOrParentType(node)) !== null && _e !== void 0 ? _e : exports.TUnknown;
        }
        else {
            return exports.TUnknown;
        }
    }
    catch (error) {
        const connection = tsyringe_1.container.resolve("Connection");
        connection.console.warn(`Error while trying to infer a type. ${error}`);
        return exports.TUnknown;
    }
}
exports.findType = findType;
//# sourceMappingURL=typeInference.js.map