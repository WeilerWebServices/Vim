"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportUtils = void 0;
const ranking_1 = __importDefault(require("../providers/ranking"));
const treeUtils_1 = require("./treeUtils");
const escape_string_regexp_1 = __importDefault(require("escape-string-regexp"));
class ImportUtils {
    static getPossibleImportsFiltered(forest, uri, filterText) {
        var _a, _b;
        const currentTree = forest.getTree(uri);
        if (currentTree) {
            const allImportedValues = treeUtils_1.TreeUtils.getAllImportedValues(forest, currentTree);
            const importedModules = (_b = (_a = treeUtils_1.TreeUtils.findAllImportClauseNodes(currentTree)) === null || _a === void 0 ? void 0 : _a.map((n) => { var _a; return (_a = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_qid", n)) === null || _a === void 0 ? void 0 : _a.text; })) !== null && _b !== void 0 ? _b : [];
            // Filter out already imported values
            // Then sort by startsWith filter text, then matches filter text
            return this.getPossibleImports(forest, uri)
                .filter((possibleImport) => !allImportedValues.find((importedValue) => {
                var _a;
                return importedValue.module === possibleImport.module &&
                    importedValue.value ===
                        ((_a = possibleImport.valueToImport) !== null && _a !== void 0 ? _a : possibleImport.value);
            }))
                .sort((a, b) => {
                var _a, _b;
                const aValue = ((_a = a.valueToImport) !== null && _a !== void 0 ? _a : a.value).toLowerCase();
                const bValue = ((_b = b.valueToImport) !== null && _b !== void 0 ? _b : b.value).toLowerCase();
                filterText = filterText.toLowerCase();
                const aStartsWith = aValue.startsWith(filterText);
                const bStartsWith = bValue.startsWith(filterText);
                if (aStartsWith && !bStartsWith) {
                    return -1;
                }
                else if (!aStartsWith && bStartsWith) {
                    return 1;
                }
                else {
                    const regex = new RegExp(escape_string_regexp_1.default(filterText));
                    const aMatches = regex.exec(aValue);
                    const bMatches = regex.exec(bValue);
                    if (aMatches && !bMatches) {
                        return -1;
                    }
                    else if (!aMatches && bMatches) {
                        return 1;
                    }
                    else {
                        const aModuleImported = importedModules.includes(a.module);
                        const bModuleImported = importedModules.includes(b.module);
                        if (aModuleImported && !bModuleImported) {
                            return -1;
                        }
                        else if (!aModuleImported && bModuleImported) {
                            return 1;
                        }
                        else {
                            return 0;
                        }
                    }
                }
            });
        }
        return [];
    }
    static getPossibleImports(forest, uri) {
        var _a;
        const currentModule = (_a = forest.getByUri(uri)) === null || _a === void 0 ? void 0 : _a.moduleName;
        const exposedValues = [];
        // Find all exposed values that could be imported
        if (forest) {
            forest.treeIndex
                .filter((tree) => tree.moduleName !== "Basics" &&
                tree.moduleName !== "Debug" &&
                tree.moduleName !== "Tuple" &&
                tree.uri !== uri)
                .forEach((tree) => {
                exposedValues.push(...ImportUtils.getPossibleImportsOfTree(tree));
            });
        }
        const ranking = ranking_1.default;
        exposedValues.sort((a, b) => {
            if (!a.package && b.package) {
                return -1;
            }
            else if (a.package && !b.package) {
                return 1;
            }
            else if (a.package && b.package) {
                const aRanking = ranking[a.package];
                const bRanking = ranking[b.package];
                if (aRanking && bRanking) {
                    return aRanking.localeCompare(bRanking);
                }
                else if (aRanking) {
                    return 1;
                }
                else if (bRanking) {
                    return -1;
                }
                else {
                    return 0;
                }
            }
            else {
                if (!currentModule) {
                    return 0;
                }
                // Sort packages that are in closest to the current module first
                const aScore = this.comparisonScore(currentModule, a.module);
                const bScore = this.comparisonScore(currentModule, b.module);
                if (aScore > bScore) {
                    return -1;
                }
                else if (bScore > aScore) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
        });
        return exposedValues;
    }
    static getPossibleImportsOfTree(tree) {
        var _a;
        const exposedValues = [];
        (_a = tree.exposing) === null || _a === void 0 ? void 0 : _a.forEach((exposed) => {
            var _a;
            const module = tree.moduleName;
            if (module) {
                exposedValues.push({
                    module,
                    value: exposed.name,
                    package: tree.maintainerAndPackageName,
                    type: exposed.type,
                    node: exposed.syntaxNode,
                });
                (_a = exposed.exposedUnionConstructors) === null || _a === void 0 ? void 0 : _a.forEach((exp) => {
                    var _a;
                    if (exp.syntaxNode.parent) {
                        const value = (_a = treeUtils_1.TreeUtils.findFirstNamedChildOfType("upper_case_identifier", exp.syntaxNode.parent)) === null || _a === void 0 ? void 0 : _a.text;
                        if (value) {
                            exposedValues.push({
                                module,
                                value: exp.name,
                                valueToImport: `${value}(..)`,
                                package: tree.maintainerAndPackageName,
                                type: "UnionConstructor",
                                node: exp.syntaxNode,
                            });
                        }
                    }
                });
            }
        });
        return exposedValues;
    }
    static comparisonScore(source, target) {
        let score = 0;
        while (score < Math.min(source.length, target.length) &&
            source.charAt(score) === target.charAt(score)) {
            score++;
        }
        return score;
    }
}
exports.ImportUtils = ImportUtils;
//# sourceMappingURL=importUtils.js.map