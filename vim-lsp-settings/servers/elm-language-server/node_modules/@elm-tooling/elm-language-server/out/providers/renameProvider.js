"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenameProvider = void 0;
const tsyringe_1 = require("tsyringe");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../util/elmWorkspaceMatcher");
const renameUtils_1 = require("../util/renameUtils");
class RenameProvider {
    constructor() {
        this.handleRenameRequest = (params, elmWorkspace) => {
            this.connection.console.info(`Renaming was requested`);
            let newName = params.newName;
            const affectedNodes = renameUtils_1.RenameUtils.getRenameAffectedNodes(elmWorkspace, params.textDocument.uri, params.position);
            newName = this.uppercaseNewNameIfModuleDeclaration(newName, affectedNodes);
            const renameChanges = [];
            const moduleDeclarationRenameChange = this.createModuleDeclarationRenameChange(affectedNodes, elmWorkspace, params, newName);
            if (moduleDeclarationRenameChange) {
                renameChanges.push(moduleDeclarationRenameChange);
            }
            const [edits, textDocumentEdits] = RenameProvider.getRenameEdits(affectedNodes, newName);
            return {
                changes: edits,
                documentChanges: [...textDocumentEdits, ...renameChanges],
            };
        };
        this.handlePrepareRenameRequest = (params, elmWorkspace) => {
            var _a, _b;
            this.connection.console.info(`Prepare rename was requested`);
            const affectedNodes = renameUtils_1.RenameUtils.getRenameAffectedNodes(elmWorkspace, params.textDocument.uri, params.position);
            if (affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.references.length) {
                //Select the whole module uppercase id `Component.Test` instead of just `Test`
                if (((_b = (_a = affectedNodes.originalNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "module_declaration") {
                    const node = affectedNodes.originalNode.parent;
                    if (node) {
                        return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(node.startPosition.row, node.startPosition.column), vscode_languageserver_1.Position.create(node.endPosition.row, node.endPosition.column));
                    }
                }
                else {
                    const node = affectedNodes.originalNode;
                    return vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(node.startPosition.row, node.startPosition.column), vscode_languageserver_1.Position.create(node.endPosition.row, node.endPosition.column));
                }
            }
            return null;
        };
        this.connection = tsyringe_1.container.resolve("Connection");
        this.connection.onPrepareRename(new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handlerForWorkspace(this.handlePrepareRenameRequest));
        this.connection.onRenameRequest(new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((params) => vscode_uri_1.URI.parse(params.textDocument.uri)).handlerForWorkspace(this.handleRenameRequest));
    }
    static getRenameEdits(affectedNodes, newName) {
        const edits = {};
        affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.references.forEach((a) => {
            if (!edits[a.uri]) {
                edits[a.uri] = [];
            }
            edits[a.uri].push(vscode_languageserver_1.TextEdit.replace(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(a.node.startPosition.row, a.node.startPosition.column), vscode_languageserver_1.Position.create(a.node.endPosition.row, a.node.endPosition.column)), newName));
        });
        const textDocumentEdits = [];
        for (const key in edits) {
            if (Object.prototype.hasOwnProperty.call(edits, key)) {
                const element = edits[key];
                textDocumentEdits.push(vscode_languageserver_1.TextDocumentEdit.create(vscode_languageserver_1.VersionedTextDocumentIdentifier.create(key, null), element));
            }
        }
        return [edits, textDocumentEdits];
    }
    createModuleDeclarationRenameChange(affectedNodes, elmWorkspace, params, newName) {
        var _a, _b;
        if (((_b = (_a = affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "module_declaration") {
            const newUri = this.generateUriFromModuleName(newName, elmWorkspace, vscode_uri_1.URI.parse(params.textDocument.uri));
            if (newUri) {
                return {
                    kind: "rename",
                    oldUri: params.textDocument.uri,
                    newUri: newUri.toString(),
                };
            }
        }
    }
    uppercaseNewNameIfModuleDeclaration(newName, affectedNodes) {
        var _a, _b;
        if (((_b = (_a = affectedNodes === null || affectedNodes === void 0 ? void 0 : affectedNodes.originalNode.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === "module_declaration") {
            return newName
                .split(".")
                .map((a) => a.charAt(0).toUpperCase() + a.slice(1))
                .join(".");
        }
        else {
            return newName;
        }
    }
    generateUriFromModuleName(moduleName, elmWorkspace, file) {
        const sourceDir = elmWorkspace.getPath(file);
        // The file is not in a source dir (shouldn't happen)
        if (!sourceDir) {
            return;
        }
        const newUri = `${sourceDir}/${moduleName.replace(/\./g, "/")}.elm`;
        return vscode_uri_1.URI.file(newUri);
    }
}
exports.RenameProvider = RenameProvider;
//# sourceMappingURL=renameProvider.js.map