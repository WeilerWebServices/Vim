"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElmMakeDiagnostics = exports.CODE_ACTION_ELM_MAKE = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-call */
const crypto_1 = require("crypto");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const tsyringe_1 = require("tsyringe");
const util_1 = __importDefault(require("util"));
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const utils = __importStar(require("../../util/elmUtils"));
const elmUtils_1 = require("../../util/elmUtils");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const importUtils_1 = require("../../util/importUtils");
const refactorEditUtils_1 = require("../../util/refactorEditUtils");
const treeUtils_1 = require("../../util/treeUtils");
const utils_1 = require("../../util/utils");
const elmDiagnosticsHelper_1 = require("./elmDiagnosticsHelper");
const ELM_MAKE = "Elm";
const NAMING_ERROR = "NAMING ERROR";
const RANDOM_ID = crypto_1.randomBytes(16).toString("hex");
exports.CODE_ACTION_ELM_MAKE = `elmLS.elmMakeFixer-${RANDOM_ID}`;
const readFile = util_1.default.promisify(fs.readFile);
function elmToolingEntrypointsDecoder(json) {
    if (typeof json === "object" && json !== null && !Array.isArray(json)) {
        if ("entrypoints" in json) {
            const { entrypoints } = json;
            if (Array.isArray(entrypoints) && entrypoints.length > 0) {
                const result = [];
                for (const [index, item] of entrypoints.entries()) {
                    if (typeof item === "string" && item.startsWith("./")) {
                        result.push(item);
                    }
                    else {
                        throw new Error(`Expected "entrypoints" to contain string paths starting with "./" but got: ${JSON.stringify(item)} at index ${index}`);
                    }
                }
                return [result[0], ...result.slice(1)];
            }
            else {
                throw new Error(`Expected "entrypoints" to be a non-empty array but got: ${JSON.stringify(json)}`);
            }
        }
        else {
            throw new Error(`There is no "entrypoints" field.`);
        }
    }
    else {
        throw new Error(`Expected a JSON object but got: ${JSON.stringify(json)}`);
    }
}
class ElmMakeDiagnostics {
    constructor() {
        this.neededImports = new Map();
        this.createDiagnostics = (filePath) => __awaiter(this, void 0, void 0, function* () {
            const workspaceRootPath = this.elmWorkspaceMatcher
                .getElmWorkspaceFor(filePath)
                .getRootPath();
            const diagnostics = yield this.checkForErrors(workspaceRootPath.fsPath, filePath.fsPath).then((issues) => {
                return issues.length === 0
                    ? new Map([[filePath.toString(), []]])
                    : elmDiagnosticsHelper_1.ElmDiagnosticsHelper.issuesToDiagnosticMap(issues, workspaceRootPath);
            });
            // Handle import all
            const forest = this.elmWorkspaceMatcher
                .getElmWorkspaceFor(filePath)
                .getForest();
            const exposedValues = importUtils_1.ImportUtils.getPossibleImports(forest, filePath.fsPath);
            // Get all possible imports from the diagnostics for import all
            diagnostics.forEach((innerDiagnostics, uri) => {
                const sourceTree = forest.getByUri(uri);
                this.neededImports.set(uri, []);
                innerDiagnostics.forEach((diagnostic) => {
                    if (diagnostic.message.startsWith(NAMING_ERROR)) {
                        const valueNode = sourceTree === null || sourceTree === void 0 ? void 0 : sourceTree.tree.rootNode.namedDescendantForPosition({
                            column: diagnostic.range.start.character,
                            row: diagnostic.range.start.line,
                        }, {
                            column: diagnostic.range.end.character,
                            row: diagnostic.range.end.line,
                        });
                        // Find imports
                        if (valueNode) {
                            exposedValues
                                .filter((exposed) => exposed.value === valueNode.text ||
                                ((valueNode.type === "upper_case_qid" ||
                                    valueNode.type === "value_qid") &&
                                    exposed.value ===
                                        valueNode.namedChildren[valueNode.namedChildren.length - 1].text &&
                                    exposed.module === valueNode.namedChildren[0].text))
                                .forEach((exposed, i) => {
                                var _a;
                                if (i === 0) {
                                    (_a = this.neededImports.get(uri)) === null || _a === void 0 ? void 0 : _a.push({
                                        moduleName: exposed.module,
                                        valueName: valueNode.type !== "upper_case_qid" &&
                                            valueNode.type !== "value_qid"
                                            ? exposed.valueToImport
                                                ? exposed.valueToImport
                                                : exposed.value
                                            : undefined,
                                        diagnostic,
                                    });
                                }
                            });
                        }
                    }
                });
            });
            return diagnostics;
        });
        this.settings = tsyringe_1.container.resolve("Settings");
        this.connection = tsyringe_1.container.resolve("Connection");
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
    }
    onCodeAction(params) {
        const { uri } = params.textDocument;
        const elmMakeDiagnostics = this.filterElmMakeDiagnostics(params.context.diagnostics);
        return this.convertDiagnosticsToCodeActions(elmMakeDiagnostics, uri);
    }
    convertDiagnosticsToCodeActions(diagnostics, uri) {
        const result = [];
        const elmWorkspace = this.elmWorkspaceMatcher.getElmWorkspaceFor(vscode_uri_1.URI.parse(uri));
        const forest = elmWorkspace.getForest();
        const exposedValues = importUtils_1.ImportUtils.getPossibleImports(forest, uri);
        const sourceTree = forest.getByUri(uri);
        diagnostics.forEach((diagnostic) => {
            var _a, _b, _c;
            if (diagnostic.message.startsWith(NAMING_ERROR)) {
                const valueNode = sourceTree === null || sourceTree === void 0 ? void 0 : sourceTree.tree.rootNode.namedDescendantForPosition({
                    column: diagnostic.range.start.character,
                    row: diagnostic.range.start.line,
                }, {
                    column: diagnostic.range.end.character,
                    row: diagnostic.range.end.line,
                });
                let hasImportFix = false;
                // Add import quick fixes
                if (valueNode) {
                    exposedValues
                        .filter((exposed) => exposed.value === valueNode.text ||
                        ((valueNode.type === "upper_case_qid" ||
                            valueNode.type === "value_qid") &&
                            exposed.value ===
                                valueNode.namedChildren[valueNode.namedChildren.length - 1]
                                    .text &&
                            exposed.module ===
                                valueNode.namedChildren
                                    .slice(0, valueNode.namedChildren.length - 2) // Dots are also namedNodes
                                    .map((a) => a.text)
                                    .join("")))
                        .forEach((exposed) => {
                        hasImportFix = true;
                        result.push(this.createImportQuickFix(uri, diagnostic, exposed.module, valueNode.type !== "upper_case_qid" &&
                            valueNode.type !== "value_qid"
                            ? exposed.valueToImport
                                ? exposed.valueToImport
                                : exposed.value
                            : undefined));
                    });
                }
                // Add import all quick fix
                const filteredImports = (_b = (_a = this.neededImports
                    .get(uri)) === null || _a === void 0 ? void 0 : _a.filter((data, i, array) => array.findIndex((d) => data.moduleName === d.moduleName &&
                    data.valueName === d.valueName) === i)) !== null && _b !== void 0 ? _b : [];
                if (hasImportFix && filteredImports.length > 1) {
                    // Sort so that the first diagnostic is this one
                    (_c = this.neededImports
                        .get(uri)) === null || _c === void 0 ? void 0 : _c.sort((a, b) => a.diagnostic.message === diagnostic.message
                        ? -1
                        : b.diagnostic.message === diagnostic.message
                            ? 1
                            : 0);
                    result.push(this.createImportAllQuickFix(uri));
                }
            }
            if (diagnostic.message.startsWith(NAMING_ERROR) ||
                diagnostic.message.startsWith("BAD IMPORT") ||
                diagnostic.message.startsWith("UNKNOWN LICENSE") ||
                diagnostic.message.startsWith("UNKNOWN PACKAGE") ||
                diagnostic.message.startsWith("UNKNOWN EXPORT")) {
                // Offer the name suggestions from elm make to our users
                const regex = /^\s{4}#(.*)#$/gm;
                let matches;
                while ((matches = regex.exec(diagnostic.message)) !== null) {
                    // This is necessary to avoid infinite loops with zero-width matches
                    if (matches.index === regex.lastIndex) {
                        regex.lastIndex++;
                    }
                    matches
                        .filter((_, groupIndex) => groupIndex === 1)
                        .forEach((match) => {
                        result.push(this.createQuickFix(uri, match, diagnostic, `Change to \`${match}\``));
                    });
                }
            }
            else if (diagnostic.message.startsWith("MODULE NAME MISMATCH") ||
                diagnostic.message.startsWith("UNEXPECTED SYMBOL")) {
                // Offer the name suggestions from elm make to our users
                const regex = /# -> #(.*)#$/gm;
                const matches = regex.exec(diagnostic.message);
                if (matches !== null) {
                    result.push(this.createQuickFix(uri, matches[1], diagnostic, `Change to \`${matches[1]}\``));
                }
            }
            else if (diagnostic.message.startsWith("UNFINISHED CASE")) {
                // Offer the case completion only if we're at the `of`
                const regex = /^\d+\|\s*.* of\s+\s+#\^#/gm;
                const matches = regex.exec(diagnostic.message);
                if (matches !== null) {
                    result.push(...this.addCaseQuickfixes(sourceTree, diagnostic, uri, elmWorkspace));
                }
            }
            else if (diagnostic.message.startsWith("MISSING PATTERNS - This `case`")) {
                result.push(...this.addCaseQuickfixes(sourceTree, diagnostic, uri, elmWorkspace));
            }
        });
        return result;
    }
    addCaseQuickfixes(sourceTree, diagnostic, uri, elmWorkspace) {
        var _a, _b, _c;
        const result = [];
        const valueNode = sourceTree === null || sourceTree === void 0 ? void 0 : sourceTree.tree.rootNode.namedDescendantForPosition({
            column: diagnostic.range.start.character,
            row: diagnostic.range.start.line,
        }, {
            column: diagnostic.range.end.character,
            row: diagnostic.range.end.line,
        });
        if (valueNode) {
            if (((_a = valueNode.firstNamedChild) === null || _a === void 0 ? void 0 : _a.type) === "case" &&
                valueNode.namedChildren.length > 1 &&
                valueNode.namedChildren[1].type === "value_expr") {
                const indent = "    ".repeat((((_b = valueNode.firstNamedChild) === null || _b === void 0 ? void 0 : _b.startPosition.column) % 4) + 1);
                const typeDeclarationNode = treeUtils_1.TreeUtils.getTypeAliasOfCase(valueNode.namedChildren[1].firstNamedChild.firstNamedChild, sourceTree.tree, uri, elmWorkspace);
                if (typeDeclarationNode) {
                    const fields = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("union_variant", typeDeclarationNode.node);
                    const alreadyAvailableBranches = (_c = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("case_of_branch", valueNode)) === null || _c === void 0 ? void 0 : _c.map((a) => { var _a, _b, _c; return (_c = (_b = (_a = a.firstNamedChild) === null || _a === void 0 ? void 0 : _a.firstNamedChild) === null || _b === void 0 ? void 0 : _b.firstNamedChild) === null || _c === void 0 ? void 0 : _c.text; }).filter(utils_1.Utils.notUndefined.bind(this));
                    let edit = "";
                    fields === null || fields === void 0 ? void 0 : fields.forEach((unionVariant) => {
                        if (!(alreadyAvailableBranches === null || alreadyAvailableBranches === void 0 ? void 0 : alreadyAvailableBranches.includes(unionVariant.firstNamedChild.text))) {
                            const parameters = treeUtils_1.TreeUtils.findAllNamedChildrenOfType("type_ref", unionVariant);
                            const caseBranch = `${[
                                unionVariant.firstNamedChild.text,
                                parameters === null || parameters === void 0 ? void 0 : parameters.map((a) => { var _a, _b; return (_b = (_a = a.firstNamedChild) === null || _a === void 0 ? void 0 : _a.lastNamedChild) === null || _b === void 0 ? void 0 : _b.text.toLowerCase(); }).join(" "),
                            ].join(" ")}`;
                            edit += `\n${indent}    ${caseBranch} ->\n${indent}        \n`;
                        }
                    });
                    result.push(this.createCaseQuickFix(uri, edit, diagnostic, `Add missing case branches`));
                }
            }
            result.push(this.createCaseQuickFix(uri, "\n\n        _ ->\n    ", diagnostic, `Add \`_\` branch`));
        }
        return result;
    }
    createCaseQuickFix(uri, replaceWith, diagnostic, title) {
        const map = {};
        if (!map[uri]) {
            map[uri] = [];
        }
        map[uri].push(vscode_languageserver_1.TextEdit.insert(diagnostic.range.end, replaceWith));
        return {
            diagnostics: [diagnostic],
            edit: { changes: map },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title,
        };
    }
    createQuickFix(uri, replaceWith, diagnostic, title) {
        const map = {};
        if (!map[uri]) {
            map[uri] = [];
        }
        map[uri].push(vscode_languageserver_1.TextEdit.replace(diagnostic.range, replaceWith));
        return {
            diagnostics: [diagnostic],
            edit: { changes: map },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title,
        };
    }
    createImportQuickFix(uri, diagnostic, moduleName, nameToImport) {
        const changes = {};
        if (!changes[uri]) {
            changes[uri] = [];
        }
        const tree = this.elmWorkspaceMatcher
            .getElmWorkspaceFor(vscode_uri_1.URI.parse(uri))
            .getForest()
            .getTree(uri);
        if (tree) {
            const edit = refactorEditUtils_1.RefactorEditUtils.addImport(tree, moduleName, nameToImport);
            if (edit) {
                changes[uri].push(edit);
            }
        }
        return {
            diagnostics: [diagnostic],
            edit: { changes },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title: nameToImport
                ? `Import '${nameToImport}' from module "${moduleName}"`
                : `Import module "${moduleName}"`,
            isPreferred: true,
        };
    }
    createImportAllQuickFix(uri) {
        const changes = {};
        if (!changes[uri]) {
            changes[uri] = [];
        }
        const tree = this.elmWorkspaceMatcher
            .getElmWorkspaceFor(vscode_uri_1.URI.parse(uri))
            .getForest()
            .getTree(uri);
        const imports = this.neededImports.get(uri);
        if (tree && imports) {
            const edit = refactorEditUtils_1.RefactorEditUtils.addImports(tree, imports);
            if (edit) {
                changes[uri].push(edit);
            }
        }
        return {
            diagnostics: imports === null || imports === void 0 ? void 0 : imports.map((data) => data.diagnostic),
            edit: { changes },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title: `Add all missing imports`,
        };
    }
    filterElmMakeDiagnostics(diagnostics) {
        return diagnostics.filter((diagnostic) => diagnostic.source === ELM_MAKE);
    }
    checkForErrors(workspaceRootPath, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const settings = yield this.settings.getClientSettings();
            const elmToolingPath = path.join(workspaceRootPath, "elm-tooling.json");
            const defaultRelativePathToFile = path.relative(workspaceRootPath, filePath);
            const [relativePathsToFiles, message] = yield readFile(elmToolingPath, {
                encoding: "utf-8",
            })
                .then(JSON.parse)
                .then(elmToolingEntrypointsDecoder)
                .then((entrypoints) => [
                entrypoints,
                `Using entrypoints from ${elmToolingPath}: ${JSON.stringify(entrypoints)}`,
            ], (error) => {
                const innerMessage = error.code === "ENOENT"
                    ? `No elm-tooling.json found in ${workspaceRootPath}.`
                    : error.code === "EISDIR"
                        ? `Skipping ${elmToolingPath} because it is a directory, not a file.`
                        : error instanceof SyntaxError
                            ? `Skipping ${elmToolingPath} because it contains invalid JSON: ${error.message}.`
                            : `Skipping ${elmToolingPath} because: ${error.message}.`;
                const fullMessage = `Using default entrypoint: ${defaultRelativePathToFile}. ${innerMessage}`;
                return [[defaultRelativePathToFile], fullMessage];
            });
            this.connection.console.info(`Find entrypoints: ${message}. See https://github.com/elm-tooling/elm-language-server#configuration for more information.`);
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const argsMake = [
                    "make",
                    ...relativePathsToFiles,
                    "--report",
                    "json",
                    "--output",
                    "/dev/null",
                ];
                const argsTest = [
                    "make",
                    ...relativePathsToFiles,
                    "--report",
                    "json",
                    "--output",
                    "/dev/null",
                ];
                const makeCommand = settings.elmPath;
                const testCommand = settings.elmTestPath;
                const isTestFile = utils.isTestFile(filePath, workspaceRootPath);
                const args = isTestFile ? argsTest : argsMake;
                const testOrMakeCommand = isTestFile ? testCommand : makeCommand;
                const testOrMakeCommandWithOmittedSettings = isTestFile
                    ? "elm-test"
                    : "elm";
                const options = {
                    cmdArguments: args,
                    notFoundText: isTestFile
                        ? "'elm-test' is not available. Install Elm via 'npm install -g elm-test'."
                        : "The 'elm' compiler is not available. Install Elm via 'npm install -g elm'.",
                };
                try {
                    // Do nothing on success, but return that there were no errors
                    yield elmUtils_1.execCmd(testOrMakeCommand, testOrMakeCommandWithOmittedSettings, options, workspaceRootPath, this.connection);
                    resolve([]);
                }
                catch (error) {
                    if (typeof error === "string") {
                        resolve([]);
                    }
                    else {
                        const execaError = error;
                        const lines = [];
                        execaError.stderr.split("\n").forEach((line) => {
                            let errorObject;
                            try {
                                errorObject = JSON.parse(line);
                            }
                            catch (error) {
                                this.connection.console.warn("Received an invalid json, skipping error.");
                            }
                            if (errorObject && errorObject.type === "compile-errors") {
                                errorObject.errors.forEach((error) => {
                                    const problems = error.problems.map((problem) => ({
                                        details: problem.message
                                            .map((message) => typeof message === "string"
                                            ? message
                                            : `#${message.string}#`)
                                            .join(""),
                                        file: error.path
                                            ? path.isAbsolute(error.path)
                                                ? path.relative(workspaceRootPath, error.path)
                                                : error.path
                                            : relativePathsToFiles[0],
                                        overview: problem.title,
                                        region: problem.region,
                                        subregion: "",
                                        tag: "error",
                                        type: "error",
                                    }));
                                    lines.push(...problems);
                                });
                            }
                            else if (errorObject && errorObject.type === "error") {
                                const problem = {
                                    details: errorObject.message
                                        .map((message) => typeof message === "string" ? message : message.string)
                                        .join(""),
                                    // elm-test might supply absolute paths to files
                                    file: errorObject.path
                                        ? path.relative(workspaceRootPath, errorObject.path)
                                        : relativePathsToFiles[0],
                                    overview: errorObject.title,
                                    region: {
                                        end: {
                                            column: 1,
                                            line: 1,
                                        },
                                        start: {
                                            column: 1,
                                            line: 1,
                                        },
                                    },
                                    subregion: "",
                                    tag: "error",
                                    type: "error",
                                };
                                lines.push(problem);
                            }
                        });
                        resolve(lines);
                    }
                }
            }));
        });
    }
}
exports.ElmMakeDiagnostics = ElmMakeDiagnostics;
//# sourceMappingURL=elmMakeDiagnostics.js.map