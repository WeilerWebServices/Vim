"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeInferenceDiagnostics = void 0;
/* eslint-disable @typescript-eslint/no-unsafe-call */
const vscode_languageserver_1 = require("vscode-languageserver");
const typeInference_1 = require("../../util/types/typeInference");
const positionUtil_1 = require("../../positionUtil");
const treeUtils_1 = require("../../util/treeUtils");
const utils_1 = require("../../util/utils");
const vscode_uri_1 = require("vscode-uri");
const elmWorkspaceMatcher_1 = require("../../util/elmWorkspaceMatcher");
const typeRenderer_1 = require("../../util/types/typeRenderer");
class TypeInferenceDiagnostics {
    constructor() {
        this.TYPE_INFERENCE = "Type Inference";
        this.createDiagnostics = (tree, uri, elmWorkspace) => {
            let diagnostics = [];
            const allTopLevelFunctions = treeUtils_1.TreeUtils.findAllTopLevelFunctionDeclarationsWithoutTypeAnnotation(tree);
            if (allTopLevelFunctions) {
                const inferencedTypes = allTopLevelFunctions
                    .filter(utils_1.Utils.notUndefinedOrNull.bind(this))
                    .map((func) => func.firstChild)
                    .filter(utils_1.Utils.notUndefinedOrNull.bind(this))
                    .map((node) => {
                    const typeString = typeRenderer_1.TypeRenderer.typeToString(typeInference_1.findType(node, uri, elmWorkspace), node.tree, uri, elmWorkspace.getImports());
                    if (typeString && typeString !== "Unknown" && node.firstNamedChild) {
                        return {
                            range: this.getNodeRange(node.firstNamedChild),
                            message: `Missing type annotation: \`${typeString}\``,
                            severity: vscode_languageserver_1.DiagnosticSeverity.Information,
                            source: this.TYPE_INFERENCE,
                        };
                    }
                })
                    .filter(utils_1.Utils.notUndefined.bind(this));
                diagnostics = inferencedTypes !== null && inferencedTypes !== void 0 ? inferencedTypes : [];
            }
            return diagnostics;
        };
        this.elmWorkspaceMatcher = new elmWorkspaceMatcher_1.ElmWorkspaceMatcher((uri) => uri);
    }
    onCodeAction(params) {
        const { uri } = params.textDocument;
        const typeInferenceDiagnostics = this.filterTypeInferenceDiagnostics(params.context.diagnostics);
        return this.convertDiagnosticsToCodeActions(typeInferenceDiagnostics, uri);
    }
    filterTypeInferenceDiagnostics(diagnostics) {
        return diagnostics.filter((diagnostic) => diagnostic.source === this.TYPE_INFERENCE);
    }
    convertDiagnosticsToCodeActions(diagnostics, uri) {
        const result = [];
        const elmWorkspace = this.elmWorkspaceMatcher.getElmWorkspaceFor(vscode_uri_1.URI.parse(uri));
        const forest = elmWorkspace.getForest();
        const treeContainer = forest.getByUri(uri);
        if (treeContainer) {
            diagnostics.forEach((diagnostic) => {
                const nodeAtPosition = treeUtils_1.TreeUtils.getNamedDescendantForPosition(treeContainer.tree.rootNode, diagnostic.range.start);
                if (nodeAtPosition.parent) {
                    const typeString = typeRenderer_1.TypeRenderer.typeToString(typeInference_1.findType(nodeAtPosition.parent, uri, elmWorkspace), nodeAtPosition.tree, uri, elmWorkspace.getImports());
                    result.push(this.insertQuickFixAtStart(uri, `${nodeAtPosition.text} : ${typeString}\n`, diagnostic, "Add inferred annotation"));
                }
            });
        }
        return result;
    }
    insertQuickFixAtStart(uri, replaceWith, diagnostic, title) {
        const map = {};
        if (!map[uri]) {
            map[uri] = [];
        }
        map[uri].push(vscode_languageserver_1.TextEdit.insert(diagnostic.range.start, replaceWith));
        return {
            diagnostics: [diagnostic],
            edit: { changes: map },
            kind: vscode_languageserver_1.CodeActionKind.QuickFix,
            title,
        };
    }
    getNodeRange(node) {
        const end = positionUtil_1.PositionUtil.FROM_TS_POSITION(node.endPosition).toVSPosition();
        return {
            start: positionUtil_1.PositionUtil.FROM_TS_POSITION(node.startPosition).toVSPosition(),
            end: Object.assign(Object.assign({}, end), { character: end.character }),
        };
    }
}
exports.TypeInferenceDiagnostics = TypeInferenceDiagnostics;
//# sourceMappingURL=typeInferenceDiagnostics.js.map